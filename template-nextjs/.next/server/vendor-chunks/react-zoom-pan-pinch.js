"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-zoom-pan-pinch";
exports.ids = ["vendor-chunks/react-zoom-pan-pinch"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-zoom-pan-pinch/dist/index.esm.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-zoom-pan-pinch/dist/index.esm.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeepScale: () => (/* binding */ KeepScale),\n/* harmony export */   TransformComponent: () => (/* binding */ TransformComponent),\n/* harmony export */   TransformWrapper: () => (/* binding */ TransformWrapper),\n/* harmony export */   getCenterPosition: () => (/* binding */ getCenterPosition),\n/* harmony export */   getMatrixTransformStyles: () => (/* binding */ getMatrixTransformStyles),\n/* harmony export */   getTransformStyles: () => (/* binding */ getTransformStyles),\n/* harmony export */   useTransformContext: () => (/* binding */ useTransformContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n/**\n * Rounds number to given decimal\n * eg. roundNumber(2.34343, 1) => 2.3\n */ var roundNumber = function(num, decimal) {\n    return Number(num.toFixed(decimal));\n};\n/**\n * Checks if value is number, if not it returns default value\n * 1# eg. checkIsNumber(2, 30) => 2\n * 2# eg. checkIsNumber(null, 30) => 30\n */ var checkIsNumber = function(num, defaultValue) {\n    return typeof num === \"number\" ? num : defaultValue;\n};\nvar handleCallback = function(context, event, callback) {\n    if (callback && typeof callback === \"function\") {\n        callback(context, event);\n    }\n};\n/* eslint-disable no-plusplus */ /* eslint-disable no-param-reassign */ /**\n * Functions should return denominator of the target value, which is the next animation step.\n * t is a value from 0 to 1, reflecting the percentage of animation status.\n */ var easeOut = function(t) {\n    return -Math.cos(t * Math.PI) / 2 + 0.5;\n};\n// linear\nvar linear = function(t) {\n    return t;\n};\n// accelerating from zero velocity\nvar easeInQuad = function(t) {\n    return t * t;\n};\n// decelerating to zero velocity\nvar easeOutQuad = function(t) {\n    return t * (2 - t);\n};\n// acceleration until halfway, then deceleration\nvar easeInOutQuad = function(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n};\n// accelerating from zero velocity\nvar easeInCubic = function(t) {\n    return t * t * t;\n};\n// decelerating to zero velocity\nvar easeOutCubic = function(t) {\n    return --t * t * t + 1;\n};\n// acceleration until halfway, then deceleration\nvar easeInOutCubic = function(t) {\n    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n};\n// accelerating from zero velocity\nvar easeInQuart = function(t) {\n    return t * t * t * t;\n};\n// decelerating to zero velocity\nvar easeOutQuart = function(t) {\n    return 1 - --t * t * t * t;\n};\n// acceleration until halfway, then deceleration\nvar easeInOutQuart = function(t) {\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n};\n// accelerating from zero velocity\nvar easeInQuint = function(t) {\n    return t * t * t * t * t;\n};\n// decelerating to zero velocity\nvar easeOutQuint = function(t) {\n    return 1 + --t * t * t * t * t;\n};\n// acceleration until halfway, then deceleration\nvar easeInOutQuint = function(t) {\n    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n};\nvar animations = {\n    easeOut: easeOut,\n    linear: linear,\n    easeInQuad: easeInQuad,\n    easeOutQuad: easeOutQuad,\n    easeInOutQuad: easeInOutQuad,\n    easeInCubic: easeInCubic,\n    easeOutCubic: easeOutCubic,\n    easeInOutCubic: easeInOutCubic,\n    easeInQuart: easeInQuart,\n    easeOutQuart: easeOutQuart,\n    easeInOutQuart: easeInOutQuart,\n    easeInQuint: easeInQuint,\n    easeOutQuint: easeOutQuint,\n    easeInOutQuint: easeInOutQuint\n};\n/* eslint-disable no-param-reassign */ var handleCancelAnimationFrame = function(animation) {\n    if (typeof animation === \"number\") {\n        cancelAnimationFrame(animation);\n    }\n};\nvar handleCancelAnimation = function(contextInstance) {\n    if (!contextInstance.mounted) return;\n    handleCancelAnimationFrame(contextInstance.animation);\n    // Clear animation state\n    contextInstance.animate = false;\n    contextInstance.animation = null;\n    contextInstance.velocity = null;\n};\nfunction handleSetupAnimation(contextInstance, animationName, animationTime, callback) {\n    if (!contextInstance.mounted) return;\n    var startTime = new Date().getTime();\n    var lastStep = 1;\n    // if another animation is active\n    handleCancelAnimation(contextInstance);\n    // new animation\n    contextInstance.animation = function() {\n        if (!contextInstance.mounted) {\n            return handleCancelAnimationFrame(contextInstance.animation);\n        }\n        var frameTime = new Date().getTime() - startTime;\n        var animationProgress = frameTime / animationTime;\n        var animationType = animations[animationName];\n        var step = animationType(animationProgress);\n        if (frameTime >= animationTime) {\n            callback(lastStep);\n            contextInstance.animation = null;\n        } else if (contextInstance.animation) {\n            callback(step);\n            requestAnimationFrame(contextInstance.animation);\n        }\n    };\n    requestAnimationFrame(contextInstance.animation);\n}\nfunction isValidTargetState(targetState) {\n    var scale = targetState.scale, positionX = targetState.positionX, positionY = targetState.positionY;\n    if (Number.isNaN(scale) || Number.isNaN(positionX) || Number.isNaN(positionY)) {\n        return false;\n    }\n    return true;\n}\nfunction animate(contextInstance, targetState, animationTime, animationName) {\n    var isValid = isValidTargetState(targetState);\n    if (!contextInstance.mounted || !isValid) return;\n    var setTransformState = contextInstance.setTransformState;\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    var scaleDiff = targetState.scale - scale;\n    var positionXDiff = targetState.positionX - positionX;\n    var positionYDiff = targetState.positionY - positionY;\n    if (animationTime === 0) {\n        setTransformState(targetState.scale, targetState.positionX, targetState.positionY);\n    } else {\n        // animation start timestamp\n        handleSetupAnimation(contextInstance, animationName, animationTime, function(step) {\n            var newScale = scale + scaleDiff * step;\n            var newPositionX = positionX + positionXDiff * step;\n            var newPositionY = positionY + positionYDiff * step;\n            setTransformState(newScale, newPositionX, newPositionY);\n        });\n    }\n}\n/* eslint-disable no-param-reassign */ function getComponentsSizes(wrapperComponent, contentComponent, newScale) {\n    var wrapperWidth = wrapperComponent.offsetWidth;\n    var wrapperHeight = wrapperComponent.offsetHeight;\n    var contentWidth = contentComponent.offsetWidth;\n    var contentHeight = contentComponent.offsetHeight;\n    var newContentWidth = contentWidth * newScale;\n    var newContentHeight = contentHeight * newScale;\n    var newDiffWidth = wrapperWidth - newContentWidth;\n    var newDiffHeight = wrapperHeight - newContentHeight;\n    return {\n        wrapperWidth: wrapperWidth,\n        wrapperHeight: wrapperHeight,\n        newContentWidth: newContentWidth,\n        newDiffWidth: newDiffWidth,\n        newContentHeight: newContentHeight,\n        newDiffHeight: newDiffHeight\n    };\n}\nvar getBounds = function(wrapperWidth, newContentWidth, diffWidth, wrapperHeight, newContentHeight, diffHeight, centerZoomedOut) {\n    var scaleWidthFactor = wrapperWidth > newContentWidth ? diffWidth * (centerZoomedOut ? 1 : 0.5) : 0;\n    var scaleHeightFactor = wrapperHeight > newContentHeight ? diffHeight * (centerZoomedOut ? 1 : 0.5) : 0;\n    var minPositionX = wrapperWidth - newContentWidth - scaleWidthFactor;\n    var maxPositionX = scaleWidthFactor;\n    var minPositionY = wrapperHeight - newContentHeight - scaleHeightFactor;\n    var maxPositionY = scaleHeightFactor;\n    return {\n        minPositionX: minPositionX,\n        maxPositionX: maxPositionX,\n        minPositionY: minPositionY,\n        maxPositionY: maxPositionY\n    };\n};\nvar calculateBounds = function(contextInstance, newScale) {\n    var wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent;\n    var centerZoomedOut = contextInstance.setup.centerZoomedOut;\n    if (!wrapperComponent || !contentComponent) {\n        throw new Error(\"Components are not mounted\");\n    }\n    var _a = getComponentsSizes(wrapperComponent, contentComponent, newScale), wrapperWidth = _a.wrapperWidth, wrapperHeight = _a.wrapperHeight, newContentWidth = _a.newContentWidth, newDiffWidth = _a.newDiffWidth, newContentHeight = _a.newContentHeight, newDiffHeight = _a.newDiffHeight;\n    var bounds = getBounds(wrapperWidth, newContentWidth, newDiffWidth, wrapperHeight, newContentHeight, newDiffHeight, Boolean(centerZoomedOut));\n    return bounds;\n};\n/**\n * Keeps value between given bounds, used for limiting view to given boundaries\n * 1# eg. boundLimiter(2, 0, 3, true) => 2\n * 2# eg. boundLimiter(4, 0, 3, true) => 3\n * 3# eg. boundLimiter(-2, 0, 3, true) => 0\n * 4# eg. boundLimiter(10, 0, 3, false) => 10\n */ var boundLimiter = function(value, minBound, maxBound, isActive) {\n    if (!isActive) return roundNumber(value, 2);\n    if (value < minBound) return roundNumber(minBound, 2);\n    if (value > maxBound) return roundNumber(maxBound, 2);\n    return roundNumber(value, 2);\n};\nvar handleCalculateBounds = function(contextInstance, newScale) {\n    var bounds = calculateBounds(contextInstance, newScale);\n    // Save bounds\n    contextInstance.bounds = bounds;\n    return bounds;\n};\nfunction getMouseBoundedPosition(positionX, positionY, bounds, limitToBounds, paddingValueX, paddingValueY, wrapperComponent) {\n    var minPositionX = bounds.minPositionX, minPositionY = bounds.minPositionY, maxPositionX = bounds.maxPositionX, maxPositionY = bounds.maxPositionY;\n    var paddingX = 0;\n    var paddingY = 0;\n    if (wrapperComponent) {\n        paddingX = paddingValueX;\n        paddingY = paddingValueY;\n    }\n    var x = boundLimiter(positionX, minPositionX - paddingX, maxPositionX + paddingX, limitToBounds);\n    var y = boundLimiter(positionY, minPositionY - paddingY, maxPositionY + paddingY, limitToBounds);\n    return {\n        x: x,\n        y: y\n    };\n}\nfunction handleCalculateZoomPositions(contextInstance, mouseX, mouseY, newScale, bounds, limitToBounds) {\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    var scaleDifference = newScale - scale;\n    if (typeof mouseX !== \"number\" || typeof mouseY !== \"number\") {\n        console.error(\"Mouse X and Y position were not provided!\");\n        return {\n            x: positionX,\n            y: positionY\n        };\n    }\n    var calculatedPositionX = positionX - mouseX * scaleDifference;\n    var calculatedPositionY = positionY - mouseY * scaleDifference;\n    // do not limit to bounds when there is padding animation,\n    // it causes animation strange behaviour\n    var newPositions = getMouseBoundedPosition(calculatedPositionX, calculatedPositionY, bounds, limitToBounds, 0, 0, null);\n    return newPositions;\n}\nfunction checkZoomBounds(zoom, minScale, maxScale, zoomPadding, enablePadding) {\n    var scalePadding = enablePadding ? zoomPadding : 0;\n    var minScaleWithPadding = minScale - scalePadding;\n    if (!Number.isNaN(maxScale) && zoom >= maxScale) return maxScale;\n    if (!Number.isNaN(minScale) && zoom <= minScaleWithPadding) return minScaleWithPadding;\n    return zoom;\n}\nvar isPanningStartAllowed = function(contextInstance, event) {\n    var excluded = contextInstance.setup.panning.excluded;\n    var isInitialized = contextInstance.isInitialized, wrapperComponent = contextInstance.wrapperComponent;\n    var target = event.target;\n    var isWrapperChild = wrapperComponent === null || wrapperComponent === void 0 ? void 0 : wrapperComponent.contains(target);\n    var isAllowed = isInitialized && target && isWrapperChild;\n    if (!isAllowed) return false;\n    var isExcluded = isExcludedNode(target, excluded);\n    if (isExcluded) return false;\n    return true;\n};\nvar isPanningAllowed = function(contextInstance) {\n    var isInitialized = contextInstance.isInitialized, isPanning = contextInstance.isPanning, setup = contextInstance.setup;\n    var disabled = setup.panning.disabled;\n    var isAllowed = isInitialized && isPanning && !disabled;\n    if (!isAllowed) return false;\n    return true;\n};\nvar handlePanningSetup = function(contextInstance, event) {\n    var _a = contextInstance.transformState, positionX = _a.positionX, positionY = _a.positionY;\n    contextInstance.isPanning = true;\n    // Panning with mouse\n    var x = event.clientX;\n    var y = event.clientY;\n    contextInstance.startCoords = {\n        x: x - positionX,\n        y: y - positionY\n    };\n};\nvar handleTouchPanningSetup = function(contextInstance, event) {\n    var touches = event.touches;\n    var _a = contextInstance.transformState, positionX = _a.positionX, positionY = _a.positionY;\n    contextInstance.isPanning = true;\n    // Panning with touch\n    var oneFingerTouch = touches.length === 1;\n    if (oneFingerTouch) {\n        var x = touches[0].clientX;\n        var y = touches[0].clientY;\n        contextInstance.startCoords = {\n            x: x - positionX,\n            y: y - positionY\n        };\n    }\n};\nfunction handlePanToBounds(contextInstance) {\n    var _a = contextInstance.transformState, positionX = _a.positionX, positionY = _a.positionY, scale = _a.scale;\n    var _b = contextInstance.setup, disabled = _b.disabled, limitToBounds = _b.limitToBounds, centerZoomedOut = _b.centerZoomedOut;\n    var wrapperComponent = contextInstance.wrapperComponent;\n    if (disabled || !wrapperComponent || !contextInstance.bounds) return;\n    var _c = contextInstance.bounds, maxPositionX = _c.maxPositionX, minPositionX = _c.minPositionX, maxPositionY = _c.maxPositionY, minPositionY = _c.minPositionY;\n    var xChanged = positionX > maxPositionX || positionX < minPositionX;\n    var yChanged = positionY > maxPositionY || positionY < minPositionY;\n    var mousePosX = positionX > maxPositionX ? wrapperComponent.offsetWidth : contextInstance.setup.minPositionX || 0;\n    var mousePosY = positionY > maxPositionY ? wrapperComponent.offsetHeight : contextInstance.setup.minPositionY || 0;\n    var _d = handleCalculateZoomPositions(contextInstance, mousePosX, mousePosY, scale, contextInstance.bounds, limitToBounds || centerZoomedOut), x = _d.x, y = _d.y;\n    return {\n        scale: scale,\n        positionX: xChanged ? x : positionX,\n        positionY: yChanged ? y : positionY\n    };\n}\nfunction handleNewPosition(contextInstance, newPositionX, newPositionY, paddingValueX, paddingValueY) {\n    var limitToBounds = contextInstance.setup.limitToBounds;\n    var wrapperComponent = contextInstance.wrapperComponent, bounds = contextInstance.bounds;\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    if (wrapperComponent === null || bounds === null || newPositionX === positionX && newPositionY === positionY) {\n        return;\n    }\n    var _b = getMouseBoundedPosition(newPositionX, newPositionY, bounds, limitToBounds, paddingValueX, paddingValueY, wrapperComponent), x = _b.x, y = _b.y;\n    contextInstance.setTransformState(scale, x, y);\n}\nvar getPanningClientPosition = function(contextInstance, clientX, clientY) {\n    var startCoords = contextInstance.startCoords, transformState = contextInstance.transformState;\n    var panning = contextInstance.setup.panning;\n    var lockAxisX = panning.lockAxisX, lockAxisY = panning.lockAxisY;\n    var positionX = transformState.positionX, positionY = transformState.positionY;\n    if (!startCoords) {\n        return {\n            x: positionX,\n            y: positionY\n        };\n    }\n    var mouseX = clientX - startCoords.x;\n    var mouseY = clientY - startCoords.y;\n    var newPositionX = lockAxisX ? positionX : mouseX;\n    var newPositionY = lockAxisY ? positionY : mouseY;\n    return {\n        x: newPositionX,\n        y: newPositionY\n    };\n};\nvar getPaddingValue = function(contextInstance, size) {\n    var setup = contextInstance.setup, transformState = contextInstance.transformState;\n    var scale = transformState.scale;\n    var minScale = setup.minScale, disablePadding = setup.disablePadding;\n    if (size > 0 && scale >= minScale && !disablePadding) {\n        return size;\n    }\n    return 0;\n};\nvar isVelocityCalculationAllowed = function(contextInstance) {\n    var mounted = contextInstance.mounted;\n    var _a = contextInstance.setup, disabled = _a.disabled, velocityAnimation = _a.velocityAnimation;\n    var scale = contextInstance.transformState.scale;\n    var disabledVelocity = velocityAnimation.disabled;\n    var isAllowed = !disabledVelocity || scale > 1 || !disabled || mounted;\n    if (!isAllowed) return false;\n    return true;\n};\nvar isVelocityAllowed = function(contextInstance) {\n    var mounted = contextInstance.mounted, velocity = contextInstance.velocity, bounds = contextInstance.bounds;\n    var _a = contextInstance.setup, disabled = _a.disabled, velocityAnimation = _a.velocityAnimation;\n    var scale = contextInstance.transformState.scale;\n    var disabledVelocity = velocityAnimation.disabled;\n    var isAllowed = !disabledVelocity || scale > 1 || !disabled || mounted;\n    if (!isAllowed) return false;\n    if (!velocity || !bounds) return false;\n    return true;\n};\nfunction getVelocityMoveTime(contextInstance, velocity) {\n    var velocityAnimation = contextInstance.setup.velocityAnimation;\n    var equalToMove = velocityAnimation.equalToMove, animationTime = velocityAnimation.animationTime, sensitivity = velocityAnimation.sensitivity;\n    if (equalToMove) {\n        return animationTime * velocity * sensitivity;\n    }\n    return animationTime;\n}\nfunction getVelocityPosition(newPosition, startPosition, currentPosition, isLocked, limitToBounds, minPosition, maxPosition, minTarget, maxTarget, step) {\n    if (limitToBounds) {\n        if (startPosition > maxPosition && currentPosition > maxPosition) {\n            var calculatedPosition = maxPosition + (newPosition - maxPosition) * step;\n            if (calculatedPosition > maxTarget) return maxTarget;\n            if (calculatedPosition < maxPosition) return maxPosition;\n            return calculatedPosition;\n        }\n        if (startPosition < minPosition && currentPosition < minPosition) {\n            var calculatedPosition = minPosition + (newPosition - minPosition) * step;\n            if (calculatedPosition < minTarget) return minTarget;\n            if (calculatedPosition > minPosition) return minPosition;\n            return calculatedPosition;\n        }\n    }\n    if (isLocked) return startPosition;\n    return boundLimiter(newPosition, minPosition, maxPosition, limitToBounds);\n}\nfunction getSizeMultiplier(wrapperComponent, equalToMove) {\n    var defaultMultiplier = 1;\n    if (equalToMove) {\n        return Math.min(defaultMultiplier, wrapperComponent.offsetWidth / window.innerWidth);\n    }\n    return defaultMultiplier;\n}\nfunction handleCalculateVelocity(contextInstance, position) {\n    var isAllowed = isVelocityCalculationAllowed(contextInstance);\n    if (!isAllowed) {\n        return;\n    }\n    var lastMousePosition = contextInstance.lastMousePosition, velocityTime = contextInstance.velocityTime, setup = contextInstance.setup;\n    var wrapperComponent = contextInstance.wrapperComponent;\n    var equalToMove = setup.velocityAnimation.equalToMove;\n    var now = Date.now();\n    if (lastMousePosition && velocityTime && wrapperComponent) {\n        var sizeMultiplier = getSizeMultiplier(wrapperComponent, equalToMove);\n        var distanceX = position.x - lastMousePosition.x;\n        var distanceY = position.y - lastMousePosition.y;\n        var velocityX = distanceX / sizeMultiplier;\n        var velocityY = distanceY / sizeMultiplier;\n        var interval = now - velocityTime;\n        var speed = distanceX * distanceX + distanceY * distanceY;\n        var velocity = Math.sqrt(speed) / interval;\n        contextInstance.velocity = {\n            velocityX: velocityX,\n            velocityY: velocityY,\n            total: velocity\n        };\n    }\n    contextInstance.lastMousePosition = position;\n    contextInstance.velocityTime = now;\n}\nfunction handleVelocityPanning(contextInstance) {\n    var velocity = contextInstance.velocity, bounds = contextInstance.bounds, setup = contextInstance.setup, wrapperComponent = contextInstance.wrapperComponent;\n    var isAllowed = isVelocityAllowed(contextInstance);\n    if (!isAllowed || !velocity || !bounds || !wrapperComponent) {\n        return;\n    }\n    var velocityX = velocity.velocityX, velocityY = velocity.velocityY, total = velocity.total;\n    var maxPositionX = bounds.maxPositionX, minPositionX = bounds.minPositionX, maxPositionY = bounds.maxPositionY, minPositionY = bounds.minPositionY;\n    var limitToBounds = setup.limitToBounds, alignmentAnimation = setup.alignmentAnimation;\n    var zoomAnimation = setup.zoomAnimation, panning = setup.panning;\n    var lockAxisY = panning.lockAxisY, lockAxisX = panning.lockAxisX;\n    var animationType = zoomAnimation.animationType;\n    var sizeX = alignmentAnimation.sizeX, sizeY = alignmentAnimation.sizeY, velocityAlignmentTime = alignmentAnimation.velocityAlignmentTime;\n    var alignAnimationTime = velocityAlignmentTime;\n    var moveAnimationTime = getVelocityMoveTime(contextInstance, total);\n    var finalAnimationTime = Math.max(moveAnimationTime, alignAnimationTime);\n    var paddingValueX = getPaddingValue(contextInstance, sizeX);\n    var paddingValueY = getPaddingValue(contextInstance, sizeY);\n    var paddingX = paddingValueX * wrapperComponent.offsetWidth / 100;\n    var paddingY = paddingValueY * wrapperComponent.offsetHeight / 100;\n    var maxTargetX = maxPositionX + paddingX;\n    var minTargetX = minPositionX - paddingX;\n    var maxTargetY = maxPositionY + paddingY;\n    var minTargetY = minPositionY - paddingY;\n    var startState = contextInstance.transformState;\n    var startTime = new Date().getTime();\n    handleSetupAnimation(contextInstance, animationType, finalAnimationTime, function(step) {\n        var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n        var frameTime = new Date().getTime() - startTime;\n        var animationProgress = frameTime / alignAnimationTime;\n        var alignAnimation = animations[alignmentAnimation.animationType];\n        var alignStep = 1 - alignAnimation(Math.min(1, animationProgress));\n        var customStep = 1 - step;\n        var newPositionX = positionX + velocityX * customStep;\n        var newPositionY = positionY + velocityY * customStep;\n        var currentPositionX = getVelocityPosition(newPositionX, startState.positionX, positionX, lockAxisX, limitToBounds, minPositionX, maxPositionX, minTargetX, maxTargetX, alignStep);\n        var currentPositionY = getVelocityPosition(newPositionY, startState.positionY, positionY, lockAxisY, limitToBounds, minPositionY, maxPositionY, minTargetY, maxTargetY, alignStep);\n        if (positionX !== newPositionX || positionY !== newPositionY) {\n            contextInstance.setTransformState(scale, currentPositionX, currentPositionY);\n        }\n    });\n}\nfunction handlePanningStart(contextInstance, event) {\n    var scale = contextInstance.transformState.scale;\n    handleCancelAnimation(contextInstance);\n    handleCalculateBounds(contextInstance, scale);\n    if (window.TouchEvent !== undefined && event instanceof TouchEvent) {\n        handleTouchPanningSetup(contextInstance, event);\n    } else {\n        handlePanningSetup(contextInstance, event);\n    }\n}\nfunction handleAlignToBounds(contextInstance) {\n    var scale = contextInstance.transformState.scale;\n    var _a = contextInstance.setup, minScale = _a.minScale, alignmentAnimation = _a.alignmentAnimation;\n    var disabled = alignmentAnimation.disabled, sizeX = alignmentAnimation.sizeX, sizeY = alignmentAnimation.sizeY, animationTime = alignmentAnimation.animationTime, animationType = alignmentAnimation.animationType;\n    var isDisabled = disabled || scale < minScale || !sizeX && !sizeY;\n    if (isDisabled) return;\n    var targetState = handlePanToBounds(contextInstance);\n    if (targetState) {\n        animate(contextInstance, targetState, animationTime, animationType);\n    }\n}\nfunction handlePanning(contextInstance, clientX, clientY) {\n    var startCoords = contextInstance.startCoords, setup = contextInstance.setup;\n    var _a = setup.alignmentAnimation, sizeX = _a.sizeX, sizeY = _a.sizeY;\n    if (!startCoords) return;\n    var _b = getPanningClientPosition(contextInstance, clientX, clientY), x = _b.x, y = _b.y;\n    var paddingValueX = getPaddingValue(contextInstance, sizeX);\n    var paddingValueY = getPaddingValue(contextInstance, sizeY);\n    handleCalculateVelocity(contextInstance, {\n        x: x,\n        y: y\n    });\n    handleNewPosition(contextInstance, x, y, paddingValueX, paddingValueY);\n}\nfunction handlePanningEnd(contextInstance) {\n    if (contextInstance.isPanning) {\n        var velocityDisabled = contextInstance.setup.panning.velocityDisabled;\n        var velocity = contextInstance.velocity, wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent;\n        contextInstance.isPanning = false;\n        contextInstance.animate = false;\n        contextInstance.animation = null;\n        var wrapperRect = wrapperComponent === null || wrapperComponent === void 0 ? void 0 : wrapperComponent.getBoundingClientRect();\n        var contentRect = contentComponent === null || contentComponent === void 0 ? void 0 : contentComponent.getBoundingClientRect();\n        var wrapperWidth = (wrapperRect === null || wrapperRect === void 0 ? void 0 : wrapperRect.width) || 0;\n        var wrapperHeight = (wrapperRect === null || wrapperRect === void 0 ? void 0 : wrapperRect.height) || 0;\n        var contentWidth = (contentRect === null || contentRect === void 0 ? void 0 : contentRect.width) || 0;\n        var contentHeight = (contentRect === null || contentRect === void 0 ? void 0 : contentRect.height) || 0;\n        var isZoomed = wrapperWidth < contentWidth || wrapperHeight < contentHeight;\n        var shouldAnimate = !velocityDisabled && velocity && (velocity === null || velocity === void 0 ? void 0 : velocity.total) > 0.1 && isZoomed;\n        if (shouldAnimate) {\n            handleVelocityPanning(contextInstance);\n        } else {\n            handleAlignToBounds(contextInstance);\n        }\n    }\n}\nfunction handleZoomToPoint(contextInstance, scale, mouseX, mouseY) {\n    var _a = contextInstance.setup, minScale = _a.minScale, maxScale = _a.maxScale, limitToBounds = _a.limitToBounds;\n    var newScale = checkZoomBounds(roundNumber(scale, 2), minScale, maxScale, 0, false);\n    var bounds = handleCalculateBounds(contextInstance, newScale);\n    var _b = handleCalculateZoomPositions(contextInstance, mouseX, mouseY, newScale, bounds, limitToBounds), x = _b.x, y = _b.y;\n    return {\n        scale: newScale,\n        positionX: x,\n        positionY: y\n    };\n}\nfunction handleAlignToScaleBounds(contextInstance, mousePositionX, mousePositionY) {\n    var scale = contextInstance.transformState.scale;\n    var wrapperComponent = contextInstance.wrapperComponent;\n    var _a = contextInstance.setup, minScale = _a.minScale, limitToBounds = _a.limitToBounds, zoomAnimation = _a.zoomAnimation;\n    var disabled = zoomAnimation.disabled, animationTime = zoomAnimation.animationTime, animationType = zoomAnimation.animationType;\n    var isDisabled = disabled || scale >= minScale;\n    if (scale >= 1 || limitToBounds) {\n        // fire fit to bounds animation\n        handleAlignToBounds(contextInstance);\n    }\n    if (isDisabled || !wrapperComponent || !contextInstance.mounted) return;\n    var mouseX = mousePositionX || wrapperComponent.offsetWidth / 2;\n    var mouseY = mousePositionY || wrapperComponent.offsetHeight / 2;\n    var targetState = handleZoomToPoint(contextInstance, minScale, mouseX, mouseY);\n    if (targetState) {\n        animate(contextInstance, targetState, animationTime, animationType);\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ var __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __spreadArray(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n}\nvar initialState = {\n    previousScale: 1,\n    scale: 1,\n    positionX: 0,\n    positionY: 0\n};\nvar initialSetup = {\n    disabled: false,\n    minPositionX: null,\n    maxPositionX: null,\n    minPositionY: null,\n    maxPositionY: null,\n    minScale: 1,\n    maxScale: 8,\n    limitToBounds: true,\n    centerZoomedOut: false,\n    centerOnInit: false,\n    disablePadding: false,\n    wheel: {\n        step: 0.2,\n        disabled: false,\n        wheelDisabled: false,\n        touchPadDisabled: false,\n        activationKeys: [],\n        excluded: []\n    },\n    panning: {\n        disabled: false,\n        velocityDisabled: false,\n        lockAxisX: false,\n        lockAxisY: false,\n        activationKeys: [],\n        excluded: []\n    },\n    pinch: {\n        step: 5,\n        disabled: false,\n        excluded: []\n    },\n    doubleClick: {\n        disabled: false,\n        step: 0.7,\n        mode: \"zoomIn\",\n        animationType: \"easeOut\",\n        animationTime: 200,\n        excluded: []\n    },\n    zoomAnimation: {\n        disabled: false,\n        size: 0.4,\n        animationTime: 200,\n        animationType: \"easeOut\"\n    },\n    alignmentAnimation: {\n        disabled: false,\n        sizeX: 100,\n        sizeY: 100,\n        animationTime: 200,\n        velocityAlignmentTime: 400,\n        animationType: \"easeOut\"\n    },\n    velocityAnimation: {\n        disabled: false,\n        sensitivity: 1,\n        animationTime: 400,\n        animationType: \"easeOut\",\n        equalToMove: true\n    }\n};\nvar createState = function(props) {\n    var _a, _b, _c, _d;\n    return {\n        previousScale: (_a = props.initialScale) !== null && _a !== void 0 ? _a : initialState.scale,\n        scale: (_b = props.initialScale) !== null && _b !== void 0 ? _b : initialState.scale,\n        positionX: (_c = props.initialPositionX) !== null && _c !== void 0 ? _c : initialState.positionX,\n        positionY: (_d = props.initialPositionY) !== null && _d !== void 0 ? _d : initialState.positionY\n    };\n};\nvar createSetup = function(props) {\n    var newSetup = __assign({}, initialSetup);\n    Object.keys(props).forEach(function(key) {\n        var validValue = typeof props[key] !== \"undefined\";\n        var validParameter = typeof initialSetup[key] !== \"undefined\";\n        if (validParameter && validValue) {\n            var dataType = Object.prototype.toString.call(initialSetup[key]);\n            var isObject = dataType === \"[object Object]\";\n            var isArray = dataType === \"[object Array]\";\n            if (isObject) {\n                newSetup[key] = __assign(__assign({}, initialSetup[key]), props[key]);\n            } else if (isArray) {\n                newSetup[key] = __spreadArray(__spreadArray([], initialSetup[key], true), props[key], true);\n            } else {\n                newSetup[key] = props[key];\n            }\n        }\n    });\n    return newSetup;\n};\nvar handleCalculateButtonZoom = function(contextInstance, delta, step) {\n    var scale = contextInstance.transformState.scale;\n    var wrapperComponent = contextInstance.wrapperComponent, setup = contextInstance.setup;\n    var maxScale = setup.maxScale, minScale = setup.minScale, zoomAnimation = setup.zoomAnimation;\n    var size = zoomAnimation.size;\n    if (!wrapperComponent) {\n        throw new Error(\"Wrapper is not mounted\");\n    }\n    var targetScale = scale * Math.exp(delta * step);\n    var newScale = checkZoomBounds(roundNumber(targetScale, 3), minScale, maxScale, size, false);\n    return newScale;\n};\nfunction handleZoomToViewCenter(contextInstance, delta, step, animationTime, animationType) {\n    var wrapperComponent = contextInstance.wrapperComponent;\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    if (!wrapperComponent) return console.error(\"No WrapperComponent found\");\n    var wrapperWidth = wrapperComponent.offsetWidth;\n    var wrapperHeight = wrapperComponent.offsetHeight;\n    var mouseX = (wrapperWidth / 2 - positionX) / scale;\n    var mouseY = (wrapperHeight / 2 - positionY) / scale;\n    var newScale = handleCalculateButtonZoom(contextInstance, delta, step);\n    var targetState = handleZoomToPoint(contextInstance, newScale, mouseX, mouseY);\n    if (!targetState) {\n        return console.error(\"Error during zoom event. New transformation state was not calculated.\");\n    }\n    animate(contextInstance, targetState, animationTime, animationType);\n}\nfunction resetTransformations(contextInstance, animationTime, animationType, onResetTransformation) {\n    var setup = contextInstance.setup, wrapperComponent = contextInstance.wrapperComponent;\n    var limitToBounds = setup.limitToBounds;\n    var initialTransformation = createState(contextInstance.props);\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    if (!wrapperComponent) return;\n    var newBounds = calculateBounds(contextInstance, initialTransformation.scale);\n    var boundedPositions = getMouseBoundedPosition(initialTransformation.positionX, initialTransformation.positionY, newBounds, limitToBounds, 0, 0, wrapperComponent);\n    var newState = {\n        scale: initialTransformation.scale,\n        positionX: boundedPositions.x,\n        positionY: boundedPositions.y\n    };\n    if (scale === initialTransformation.scale && positionX === initialTransformation.positionX && positionY === initialTransformation.positionY) {\n        return;\n    }\n    onResetTransformation === null || onResetTransformation === void 0 ? void 0 : onResetTransformation();\n    animate(contextInstance, newState, animationTime, animationType);\n}\nfunction getOffset(element, wrapper, content, state) {\n    var offset = element.getBoundingClientRect();\n    var wrapperOffset = wrapper.getBoundingClientRect();\n    var contentOffset = content.getBoundingClientRect();\n    var xOff = wrapperOffset.x * state.scale;\n    var yOff = wrapperOffset.y * state.scale;\n    return {\n        x: (offset.x - contentOffset.x + xOff) / state.scale,\n        y: (offset.y - contentOffset.y + yOff) / state.scale\n    };\n}\nfunction calculateZoomToNode(contextInstance, node, customZoom) {\n    var wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent, transformState = contextInstance.transformState;\n    var _a = contextInstance.setup, limitToBounds = _a.limitToBounds, minScale = _a.minScale, maxScale = _a.maxScale;\n    if (!wrapperComponent || !contentComponent) return transformState;\n    var wrapperRect = wrapperComponent.getBoundingClientRect();\n    var nodeRect = node.getBoundingClientRect();\n    var nodeOffset = getOffset(node, wrapperComponent, contentComponent, transformState);\n    var nodeLeft = nodeOffset.x;\n    var nodeTop = nodeOffset.y;\n    var nodeWidth = nodeRect.width / transformState.scale;\n    var nodeHeight = nodeRect.height / transformState.scale;\n    var scaleX = wrapperComponent.offsetWidth / nodeWidth;\n    var scaleY = wrapperComponent.offsetHeight / nodeHeight;\n    var newScale = checkZoomBounds(customZoom || Math.min(scaleX, scaleY), minScale, maxScale, 0, false);\n    var offsetX = (wrapperRect.width - nodeWidth * newScale) / 2;\n    var offsetY = (wrapperRect.height - nodeHeight * newScale) / 2;\n    var newPositionX = (wrapperRect.left - nodeLeft) * newScale + offsetX;\n    var newPositionY = (wrapperRect.top - nodeTop) * newScale + offsetY;\n    var bounds = calculateBounds(contextInstance, newScale);\n    var _b = getMouseBoundedPosition(newPositionX, newPositionY, bounds, limitToBounds, 0, 0, wrapperComponent), x = _b.x, y = _b.y;\n    return {\n        positionX: x,\n        positionY: y,\n        scale: newScale\n    };\n}\nvar zoomIn = function(contextInstance) {\n    return function(step, animationTime, animationType) {\n        if (step === void 0) {\n            step = 0.5;\n        }\n        if (animationTime === void 0) {\n            animationTime = 300;\n        }\n        if (animationType === void 0) {\n            animationType = \"easeOut\";\n        }\n        handleZoomToViewCenter(contextInstance, 1, step, animationTime, animationType);\n    };\n};\nvar zoomOut = function(contextInstance) {\n    return function(step, animationTime, animationType) {\n        if (step === void 0) {\n            step = 0.5;\n        }\n        if (animationTime === void 0) {\n            animationTime = 300;\n        }\n        if (animationType === void 0) {\n            animationType = \"easeOut\";\n        }\n        handleZoomToViewCenter(contextInstance, -1, step, animationTime, animationType);\n    };\n};\nvar setTransform = function(contextInstance) {\n    return function(newPositionX, newPositionY, newScale, animationTime, animationType) {\n        if (animationTime === void 0) {\n            animationTime = 300;\n        }\n        if (animationType === void 0) {\n            animationType = \"easeOut\";\n        }\n        var _a = contextInstance.transformState, positionX = _a.positionX, positionY = _a.positionY, scale = _a.scale;\n        var wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent;\n        var disabled = contextInstance.setup.disabled;\n        if (disabled || !wrapperComponent || !contentComponent) return;\n        var targetState = {\n            positionX: Number.isNaN(newPositionX) ? positionX : newPositionX,\n            positionY: Number.isNaN(newPositionY) ? positionY : newPositionY,\n            scale: Number.isNaN(newScale) ? scale : newScale\n        };\n        animate(contextInstance, targetState, animationTime, animationType);\n    };\n};\nvar resetTransform = function(contextInstance) {\n    return function(animationTime, animationType) {\n        if (animationTime === void 0) {\n            animationTime = 200;\n        }\n        if (animationType === void 0) {\n            animationType = \"easeOut\";\n        }\n        resetTransformations(contextInstance, animationTime, animationType);\n    };\n};\nvar centerView = function(contextInstance) {\n    return function(scale, animationTime, animationType) {\n        if (animationTime === void 0) {\n            animationTime = 200;\n        }\n        if (animationType === void 0) {\n            animationType = \"easeOut\";\n        }\n        var transformState = contextInstance.transformState, wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent;\n        if (wrapperComponent && contentComponent) {\n            var targetState = getCenterPosition(scale || transformState.scale, wrapperComponent, contentComponent);\n            animate(contextInstance, targetState, animationTime, animationType);\n        }\n    };\n};\nvar zoomToElement = function(contextInstance) {\n    return function(node, scale, animationTime, animationType) {\n        if (animationTime === void 0) {\n            animationTime = 600;\n        }\n        if (animationType === void 0) {\n            animationType = \"easeOut\";\n        }\n        handleCancelAnimation(contextInstance);\n        var wrapperComponent = contextInstance.wrapperComponent;\n        var target = typeof node === \"string\" ? document.getElementById(node) : node;\n        if (wrapperComponent && target && wrapperComponent.contains(target)) {\n            var targetState = calculateZoomToNode(contextInstance, target, scale);\n            animate(contextInstance, targetState, animationTime, animationType);\n        }\n    };\n};\nvar getContext = function(contextInstance) {\n    return {\n        instance: contextInstance,\n        state: contextInstance.transformState,\n        zoomIn: zoomIn(contextInstance),\n        zoomOut: zoomOut(contextInstance),\n        setTransform: setTransform(contextInstance),\n        resetTransform: resetTransform(contextInstance),\n        centerView: centerView(contextInstance),\n        zoomToElement: zoomToElement(contextInstance)\n    };\n};\n// We want to make event listeners non-passive, and to do so have to check\n// that browsers support EventListenerOptions in the first place.\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\nvar passiveSupported = false;\nfunction makePassiveEventOption() {\n    try {\n        var options = {\n            get passive () {\n                // This function will be called when the browser\n                //   attempts to access the passive property.\n                passiveSupported = true;\n                return false;\n            }\n        };\n        return options;\n    } catch (err) {\n        passiveSupported = false;\n        return passiveSupported;\n    }\n}\nvar isExcludedNode = function(node, excluded) {\n    var targetTagName = node.tagName.toUpperCase();\n    var isExcludedTag = excluded.find(function(tag) {\n        return tag.toUpperCase() === targetTagName;\n    });\n    if (isExcludedTag) return true;\n    var isExcludedClassName = excluded.find(function(className) {\n        return node.classList.contains(className);\n    });\n    if (isExcludedClassName) return true;\n    return false;\n};\nvar cancelTimeout = function(timeout) {\n    if (timeout) {\n        clearTimeout(timeout);\n    }\n};\nvar getTransformStyles = function(x, y, scale) {\n    // Standard translate prevents blurry svg on the safari\n    return \"translate(\".concat(x, \"px, \").concat(y, \"px) scale(\").concat(scale, \")\");\n};\nvar getMatrixTransformStyles = function(x, y, scale) {\n    // The shorthand for matrix does not work for Safari hence the need to explicitly use matrix3d\n    // Refer to https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n    var a = scale;\n    var b = 0;\n    var c = 0;\n    var d = scale;\n    var tx = x;\n    var ty = y;\n    return \"matrix3d(\".concat(a, \", \").concat(b, \", 0, 0, \").concat(c, \", \").concat(d, \", 0, 0, 0, 0, 1, 0, \").concat(tx, \", \").concat(ty, \", 0, 1)\");\n};\nvar getCenterPosition = function(scale, wrapperComponent, contentComponent) {\n    var contentWidth = contentComponent.offsetWidth * scale;\n    var contentHeight = contentComponent.offsetHeight * scale;\n    var centerPositionX = (wrapperComponent.offsetWidth - contentWidth) / 2;\n    var centerPositionY = (wrapperComponent.offsetHeight - contentHeight) / 2;\n    return {\n        scale: scale,\n        positionX: centerPositionX,\n        positionY: centerPositionY\n    };\n};\nfunction mergeRefs(refs) {\n    return function(value) {\n        refs.forEach(function(ref) {\n            if (typeof ref === \"function\") {\n                ref(value);\n            } else if (ref != null) {\n                ref.current = value;\n            }\n        });\n    };\n}\nvar isWheelAllowed = function(contextInstance, event) {\n    var _a = contextInstance.setup.wheel, disabled = _a.disabled, wheelDisabled = _a.wheelDisabled, touchPadDisabled = _a.touchPadDisabled, excluded = _a.excluded;\n    var isInitialized = contextInstance.isInitialized, isPanning = contextInstance.isPanning;\n    var target = event.target;\n    var isAllowed = isInitialized && !isPanning && !disabled && target;\n    if (!isAllowed) return false;\n    // Event ctrlKey detects if touchpad action is executing wheel or pinch gesture\n    if (wheelDisabled && !event.ctrlKey) return false;\n    if (touchPadDisabled && event.ctrlKey) return false;\n    var isExcluded = isExcludedNode(target, excluded);\n    if (isExcluded) return false;\n    return true;\n};\nvar getDeltaY = function(event) {\n    if (event) {\n        return event.deltaY < 0 ? 1 : -1;\n    }\n    return 0;\n};\nfunction getDelta(event, customDelta) {\n    var deltaY = getDeltaY(event);\n    var delta = checkIsNumber(customDelta, deltaY);\n    return delta;\n}\nfunction getMousePosition(event, contentComponent, scale) {\n    var contentRect = contentComponent.getBoundingClientRect();\n    var mouseX = 0;\n    var mouseY = 0;\n    if (\"clientX\" in event) {\n        // mouse position x, y over wrapper component\n        mouseX = (event.clientX - contentRect.left) / scale;\n        mouseY = (event.clientY - contentRect.top) / scale;\n    } else {\n        var touch = event.touches[0];\n        mouseX = (touch.clientX - contentRect.left) / scale;\n        mouseY = (touch.clientY - contentRect.top) / scale;\n    }\n    if (Number.isNaN(mouseX) || Number.isNaN(mouseY)) console.error(\"No mouse or touch offset found\");\n    return {\n        x: mouseX,\n        y: mouseY\n    };\n}\nvar handleCalculateWheelZoom = function(contextInstance, delta, step, disable, getTarget) {\n    var scale = contextInstance.transformState.scale;\n    var wrapperComponent = contextInstance.wrapperComponent, setup = contextInstance.setup;\n    var maxScale = setup.maxScale, minScale = setup.minScale, zoomAnimation = setup.zoomAnimation, disablePadding = setup.disablePadding;\n    var size = zoomAnimation.size, disabled = zoomAnimation.disabled;\n    if (!wrapperComponent) {\n        throw new Error(\"Wrapper is not mounted\");\n    }\n    var targetScale = scale + delta * (scale - scale * step) * step;\n    if (getTarget) return targetScale;\n    var paddingEnabled = disable ? false : !disabled;\n    var newScale = checkZoomBounds(roundNumber(targetScale, 3), minScale, maxScale, size, paddingEnabled && !disablePadding);\n    return newScale;\n};\nvar handleWheelZoomStop = function(contextInstance, event) {\n    var previousWheelEvent = contextInstance.previousWheelEvent;\n    var scale = contextInstance.transformState.scale;\n    var _a = contextInstance.setup, maxScale = _a.maxScale, minScale = _a.minScale;\n    if (!previousWheelEvent) return false;\n    if (scale < maxScale || scale > minScale) return true;\n    if (Math.sign(previousWheelEvent.deltaY) !== Math.sign(event.deltaY)) return true;\n    if (previousWheelEvent.deltaY > 0 && previousWheelEvent.deltaY < event.deltaY) return true;\n    if (previousWheelEvent.deltaY < 0 && previousWheelEvent.deltaY > event.deltaY) return true;\n    if (Math.sign(previousWheelEvent.deltaY) !== Math.sign(event.deltaY)) return true;\n    return false;\n};\nvar isPinchStartAllowed = function(contextInstance, event) {\n    var _a = contextInstance.setup.pinch, disabled = _a.disabled, excluded = _a.excluded;\n    var isInitialized = contextInstance.isInitialized;\n    var target = event.target;\n    var isAllowed = isInitialized && !disabled && target;\n    if (!isAllowed) return false;\n    var isExcluded = isExcludedNode(target, excluded);\n    if (isExcluded) return false;\n    return true;\n};\nvar isPinchAllowed = function(contextInstance) {\n    var disabled = contextInstance.setup.pinch.disabled;\n    var isInitialized = contextInstance.isInitialized, pinchStartDistance = contextInstance.pinchStartDistance;\n    var isAllowed = isInitialized && !disabled && pinchStartDistance;\n    if (!isAllowed) return false;\n    return true;\n};\nvar calculateTouchMidPoint = function(event, scale, contentComponent) {\n    var contentRect = contentComponent.getBoundingClientRect();\n    var touches = event.touches;\n    var firstPointX = roundNumber(touches[0].clientX - contentRect.left, 5);\n    var firstPointY = roundNumber(touches[0].clientY - contentRect.top, 5);\n    var secondPointX = roundNumber(touches[1].clientX - contentRect.left, 5);\n    var secondPointY = roundNumber(touches[1].clientY - contentRect.top, 5);\n    return {\n        x: (firstPointX + secondPointX) / 2 / scale,\n        y: (firstPointY + secondPointY) / 2 / scale\n    };\n};\nvar getTouchDistance = function(event) {\n    return Math.sqrt(Math.pow(event.touches[0].pageX - event.touches[1].pageX, 2) + Math.pow(event.touches[0].pageY - event.touches[1].pageY, 2));\n};\nvar calculatePinchZoom = function(contextInstance, currentDistance) {\n    var pinchStartScale = contextInstance.pinchStartScale, pinchStartDistance = contextInstance.pinchStartDistance, setup = contextInstance.setup;\n    var maxScale = setup.maxScale, minScale = setup.minScale, zoomAnimation = setup.zoomAnimation, disablePadding = setup.disablePadding;\n    var size = zoomAnimation.size, disabled = zoomAnimation.disabled;\n    if (!pinchStartScale || pinchStartDistance === null || !currentDistance) {\n        throw new Error(\"Pinch touches distance was not provided\");\n    }\n    if (currentDistance < 0) {\n        return contextInstance.transformState.scale;\n    }\n    var touchProportion = currentDistance / pinchStartDistance;\n    var scaleDifference = touchProportion * pinchStartScale;\n    return checkZoomBounds(roundNumber(scaleDifference, 2), minScale, maxScale, size, !disabled && !disablePadding);\n};\nvar wheelStopEventTime = 160;\nvar wheelAnimationTime = 100;\nvar handleWheelStart = function(contextInstance, event) {\n    var _a = contextInstance.props, onWheelStart = _a.onWheelStart, onZoomStart = _a.onZoomStart;\n    if (!contextInstance.wheelStopEventTimer) {\n        handleCancelAnimation(contextInstance);\n        handleCallback(getContext(contextInstance), event, onWheelStart);\n        handleCallback(getContext(contextInstance), event, onZoomStart);\n    }\n};\nvar handleWheelZoom = function(contextInstance, event) {\n    var _a = contextInstance.props, onWheel = _a.onWheel, onZoom = _a.onZoom;\n    var contentComponent = contextInstance.contentComponent, setup = contextInstance.setup, transformState = contextInstance.transformState;\n    var scale = transformState.scale;\n    var limitToBounds = setup.limitToBounds, centerZoomedOut = setup.centerZoomedOut, zoomAnimation = setup.zoomAnimation, wheel = setup.wheel, disablePadding = setup.disablePadding;\n    var size = zoomAnimation.size, disabled = zoomAnimation.disabled;\n    var step = wheel.step;\n    if (!contentComponent) {\n        throw new Error(\"Component not mounted\");\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    var delta = getDelta(event, null);\n    var newScale = handleCalculateWheelZoom(contextInstance, delta, step, !event.ctrlKey);\n    // if scale not change\n    if (scale === newScale) return;\n    var bounds = handleCalculateBounds(contextInstance, newScale);\n    var mousePosition = getMousePosition(event, contentComponent, scale);\n    var isPaddingDisabled = disabled || size === 0 || centerZoomedOut || disablePadding;\n    var isLimitedToBounds = limitToBounds && isPaddingDisabled;\n    var _b = handleCalculateZoomPositions(contextInstance, mousePosition.x, mousePosition.y, newScale, bounds, isLimitedToBounds), x = _b.x, y = _b.y;\n    contextInstance.previousWheelEvent = event;\n    contextInstance.setTransformState(newScale, x, y);\n    handleCallback(getContext(contextInstance), event, onWheel);\n    handleCallback(getContext(contextInstance), event, onZoom);\n};\nvar handleWheelStop = function(contextInstance, event) {\n    var _a = contextInstance.props, onWheelStop = _a.onWheelStop, onZoomStop = _a.onZoomStop;\n    // fire animation\n    cancelTimeout(contextInstance.wheelAnimationTimer);\n    contextInstance.wheelAnimationTimer = setTimeout(function() {\n        if (!contextInstance.mounted) return;\n        handleAlignToScaleBounds(contextInstance, event.x, event.y);\n        contextInstance.wheelAnimationTimer = null;\n    }, wheelAnimationTime);\n    // Wheel stop event\n    var hasStoppedZooming = handleWheelZoomStop(contextInstance, event);\n    if (hasStoppedZooming) {\n        cancelTimeout(contextInstance.wheelStopEventTimer);\n        contextInstance.wheelStopEventTimer = setTimeout(function() {\n            if (!contextInstance.mounted) return;\n            contextInstance.wheelStopEventTimer = null;\n            handleCallback(getContext(contextInstance), event, onWheelStop);\n            handleCallback(getContext(contextInstance), event, onZoomStop);\n        }, wheelStopEventTime);\n    }\n};\nvar handlePinchStart = function(contextInstance, event) {\n    var distance = getTouchDistance(event);\n    contextInstance.pinchStartDistance = distance;\n    contextInstance.lastDistance = distance;\n    contextInstance.pinchStartScale = contextInstance.transformState.scale;\n    contextInstance.isPanning = false;\n    handleCancelAnimation(contextInstance);\n};\nvar handlePinchZoom = function(contextInstance, event) {\n    var contentComponent = contextInstance.contentComponent, pinchStartDistance = contextInstance.pinchStartDistance;\n    var scale = contextInstance.transformState.scale;\n    var _a = contextInstance.setup, limitToBounds = _a.limitToBounds, centerZoomedOut = _a.centerZoomedOut, zoomAnimation = _a.zoomAnimation;\n    var disabled = zoomAnimation.disabled, size = zoomAnimation.size;\n    // if one finger starts from outside of wrapper\n    if (pinchStartDistance === null || !contentComponent) return;\n    var midPoint = calculateTouchMidPoint(event, scale, contentComponent);\n    // if touches goes off of the wrapper element\n    if (!Number.isFinite(midPoint.x) || !Number.isFinite(midPoint.y)) return;\n    var currentDistance = getTouchDistance(event);\n    var newScale = calculatePinchZoom(contextInstance, currentDistance);\n    if (newScale === scale) return;\n    var bounds = handleCalculateBounds(contextInstance, newScale);\n    var isPaddingDisabled = disabled || size === 0 || centerZoomedOut;\n    var isLimitedToBounds = limitToBounds && isPaddingDisabled;\n    var _b = handleCalculateZoomPositions(contextInstance, midPoint.x, midPoint.y, newScale, bounds, isLimitedToBounds), x = _b.x, y = _b.y;\n    contextInstance.pinchMidpoint = midPoint;\n    contextInstance.lastDistance = currentDistance;\n    contextInstance.setTransformState(newScale, x, y);\n};\nvar handlePinchStop = function(contextInstance) {\n    var pinchMidpoint = contextInstance.pinchMidpoint;\n    contextInstance.velocity = null;\n    contextInstance.lastDistance = null;\n    contextInstance.pinchMidpoint = null;\n    contextInstance.pinchStartScale = null;\n    contextInstance.pinchStartDistance = null;\n    handleAlignToScaleBounds(contextInstance, pinchMidpoint === null || pinchMidpoint === void 0 ? void 0 : pinchMidpoint.x, pinchMidpoint === null || pinchMidpoint === void 0 ? void 0 : pinchMidpoint.y);\n};\nvar handleDoubleClickStop = function(contextInstance, event) {\n    var onZoomStop = contextInstance.props.onZoomStop;\n    var animationTime = contextInstance.setup.doubleClick.animationTime;\n    cancelTimeout(contextInstance.doubleClickStopEventTimer);\n    contextInstance.doubleClickStopEventTimer = setTimeout(function() {\n        contextInstance.doubleClickStopEventTimer = null;\n        handleCallback(getContext(contextInstance), event, onZoomStop);\n    }, animationTime);\n};\nvar handleDoubleClickResetMode = function(contextInstance, event) {\n    var _a = contextInstance.props, onZoomStart = _a.onZoomStart, onZoom = _a.onZoom;\n    var _b = contextInstance.setup.doubleClick, animationTime = _b.animationTime, animationType = _b.animationType;\n    handleCallback(getContext(contextInstance), event, onZoomStart);\n    resetTransformations(contextInstance, animationTime, animationType, function() {\n        return handleCallback(getContext(contextInstance), event, onZoom);\n    });\n    handleDoubleClickStop(contextInstance, event);\n};\nfunction handleDoubleClick(contextInstance, event) {\n    var setup = contextInstance.setup, doubleClickStopEventTimer = contextInstance.doubleClickStopEventTimer, transformState = contextInstance.transformState, contentComponent = contextInstance.contentComponent;\n    var scale = transformState.scale;\n    var _a = contextInstance.props, onZoomStart = _a.onZoomStart, onZoom = _a.onZoom;\n    var _b = setup.doubleClick, disabled = _b.disabled, mode = _b.mode, step = _b.step, animationTime = _b.animationTime, animationType = _b.animationType;\n    if (disabled) return;\n    if (doubleClickStopEventTimer) return;\n    if (mode === \"reset\") {\n        return handleDoubleClickResetMode(contextInstance, event);\n    }\n    if (!contentComponent) return console.error(\"No ContentComponent found\");\n    var delta = mode === \"zoomOut\" ? -1 : 1;\n    var newScale = handleCalculateButtonZoom(contextInstance, delta, step);\n    // stop execution when scale didn't change\n    if (scale === newScale) return;\n    handleCallback(getContext(contextInstance), event, onZoomStart);\n    var mousePosition = getMousePosition(event, contentComponent, scale);\n    var targetState = handleZoomToPoint(contextInstance, newScale, mousePosition.x, mousePosition.y);\n    if (!targetState) {\n        return console.error(\"Error during zoom event. New transformation state was not calculated.\");\n    }\n    handleCallback(getContext(contextInstance), event, onZoom);\n    animate(contextInstance, targetState, animationTime, animationType);\n    handleDoubleClickStop(contextInstance, event);\n}\nvar isDoubleClickAllowed = function(contextInstance, event) {\n    var isInitialized = contextInstance.isInitialized, setup = contextInstance.setup, wrapperComponent = contextInstance.wrapperComponent;\n    var _a = setup.doubleClick, disabled = _a.disabled, excluded = _a.excluded;\n    var target = event.target;\n    var isWrapperChild = wrapperComponent === null || wrapperComponent === void 0 ? void 0 : wrapperComponent.contains(target);\n    var isAllowed = isInitialized && target && isWrapperChild && !disabled;\n    if (!isAllowed) return false;\n    var isExcluded = isExcludedNode(target, excluded);\n    if (isExcluded) return false;\n    return true;\n};\nvar ZoomPanPinch = /** @class */ function() {\n    function ZoomPanPinch(props) {\n        var _this = this;\n        this.mounted = true;\n        this.onChangeCallbacks = new Set();\n        // Components\n        this.wrapperComponent = null;\n        this.contentComponent = null;\n        // Initialization\n        this.isInitialized = false;\n        this.bounds = null;\n        // wheel helpers\n        this.previousWheelEvent = null;\n        this.wheelStopEventTimer = null;\n        this.wheelAnimationTimer = null;\n        // panning helpers\n        this.isPanning = false;\n        this.startCoords = null;\n        this.lastTouch = null;\n        // pinch helpers\n        this.distance = null;\n        this.lastDistance = null;\n        this.pinchStartDistance = null;\n        this.pinchStartScale = null;\n        this.pinchMidpoint = null;\n        // double click helpers\n        this.doubleClickStopEventTimer = null;\n        // velocity helpers\n        this.velocity = null;\n        this.velocityTime = null;\n        this.lastMousePosition = null;\n        // animations helpers\n        this.animate = false;\n        this.animation = null;\n        this.maxBounds = null;\n        // key press\n        this.pressedKeys = {};\n        this.mount = function() {\n            _this.initializeWindowEvents();\n        };\n        this.unmount = function() {\n            _this.cleanupWindowEvents();\n        };\n        this.update = function(newProps) {\n            handleCalculateBounds(_this, _this.transformState.scale);\n            _this.setup = createSetup(newProps);\n        };\n        this.initializeWindowEvents = function() {\n            var _a;\n            var passive = makePassiveEventOption();\n            var currentDocument = (_a = _this.wrapperComponent) === null || _a === void 0 ? void 0 : _a.ownerDocument;\n            var currentWindow = currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.defaultView;\n            // Panning on window to allow panning when mouse is out of component wrapper\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.addEventListener(\"mousedown\", _this.onPanningStart, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.addEventListener(\"mousemove\", _this.onPanning, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.addEventListener(\"mouseup\", _this.onPanningStop, passive);\n            currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.addEventListener(\"mouseleave\", _this.clearPanning, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.addEventListener(\"keyup\", _this.setKeyUnPressed, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.addEventListener(\"keydown\", _this.setKeyPressed, passive);\n        };\n        this.cleanupWindowEvents = function() {\n            var _a, _b;\n            var passive = makePassiveEventOption();\n            var currentDocument = (_a = _this.wrapperComponent) === null || _a === void 0 ? void 0 : _a.ownerDocument;\n            var currentWindow = currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.defaultView;\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.removeEventListener(\"mousedown\", _this.onPanningStart, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.removeEventListener(\"mousemove\", _this.onPanning, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.removeEventListener(\"mouseup\", _this.onPanningStop, passive);\n            currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.removeEventListener(\"mouseleave\", _this.clearPanning, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.removeEventListener(\"keyup\", _this.setKeyUnPressed, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.removeEventListener(\"keydown\", _this.setKeyPressed, passive);\n            document.removeEventListener(\"mouseleave\", _this.clearPanning, passive);\n            handleCancelAnimation(_this);\n            (_b = _this.observer) === null || _b === void 0 ? void 0 : _b.disconnect();\n        };\n        this.handleInitializeWrapperEvents = function(wrapper) {\n            // Zooming events on wrapper\n            var passive = makePassiveEventOption();\n            wrapper.addEventListener(\"wheel\", _this.onWheelZoom, passive);\n            wrapper.addEventListener(\"dblclick\", _this.onDoubleClick, passive);\n            wrapper.addEventListener(\"touchstart\", _this.onTouchPanningStart, passive);\n            wrapper.addEventListener(\"touchmove\", _this.onTouchPanning, passive);\n            wrapper.addEventListener(\"touchend\", _this.onTouchPanningStop, passive);\n        };\n        this.handleInitialize = function(contentComponent) {\n            var centerOnInit = _this.setup.centerOnInit;\n            _this.applyTransformation();\n            if (centerOnInit) {\n                _this.setCenter();\n                _this.observer = new ResizeObserver(function() {\n                    var _a;\n                    _this.setCenter();\n                    (_a = _this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();\n                });\n                // Start observing the target node for configured mutations\n                _this.observer.observe(contentComponent);\n            }\n        };\n        /// ///////\n        // Zoom\n        /// ///////\n        this.onWheelZoom = function(event) {\n            var disabled = _this.setup.disabled;\n            if (disabled) return;\n            var isAllowed = isWheelAllowed(_this, event);\n            if (!isAllowed) return;\n            var keysPressed = _this.isPressingKeys(_this.setup.wheel.activationKeys);\n            if (!keysPressed) return;\n            handleWheelStart(_this, event);\n            handleWheelZoom(_this, event);\n            handleWheelStop(_this, event);\n        };\n        /// ///////\n        // Pan\n        /// ///////\n        this.onPanningStart = function(event) {\n            var disabled = _this.setup.disabled;\n            var onPanningStart = _this.props.onPanningStart;\n            if (disabled) return;\n            var isAllowed = isPanningStartAllowed(_this, event);\n            if (!isAllowed) return;\n            var keysPressed = _this.isPressingKeys(_this.setup.panning.activationKeys);\n            if (!keysPressed) return;\n            event.preventDefault();\n            event.stopPropagation();\n            handleCancelAnimation(_this);\n            handlePanningStart(_this, event);\n            handleCallback(getContext(_this), event, onPanningStart);\n        };\n        this.onPanning = function(event) {\n            var disabled = _this.setup.disabled;\n            var onPanning = _this.props.onPanning;\n            if (disabled) return;\n            var isAllowed = isPanningAllowed(_this);\n            if (!isAllowed) return;\n            var keysPressed = _this.isPressingKeys(_this.setup.panning.activationKeys);\n            if (!keysPressed) return;\n            event.preventDefault();\n            event.stopPropagation();\n            handlePanning(_this, event.clientX, event.clientY);\n            handleCallback(getContext(_this), event, onPanning);\n        };\n        this.onPanningStop = function(event) {\n            var onPanningStop = _this.props.onPanningStop;\n            if (_this.isPanning) {\n                handlePanningEnd(_this);\n                handleCallback(getContext(_this), event, onPanningStop);\n            }\n        };\n        /// ///////\n        // Pinch\n        /// ///////\n        this.onPinchStart = function(event) {\n            var disabled = _this.setup.disabled;\n            var _a = _this.props, onPinchingStart = _a.onPinchingStart, onZoomStart = _a.onZoomStart;\n            if (disabled) return;\n            var isAllowed = isPinchStartAllowed(_this, event);\n            if (!isAllowed) return;\n            handlePinchStart(_this, event);\n            handleCancelAnimation(_this);\n            handleCallback(getContext(_this), event, onPinchingStart);\n            handleCallback(getContext(_this), event, onZoomStart);\n        };\n        this.onPinch = function(event) {\n            var disabled = _this.setup.disabled;\n            var _a = _this.props, onPinching = _a.onPinching, onZoom = _a.onZoom;\n            if (disabled) return;\n            var isAllowed = isPinchAllowed(_this);\n            if (!isAllowed) return;\n            event.preventDefault();\n            event.stopPropagation();\n            handlePinchZoom(_this, event);\n            handleCallback(getContext(_this), event, onPinching);\n            handleCallback(getContext(_this), event, onZoom);\n        };\n        this.onPinchStop = function(event) {\n            var _a = _this.props, onPinchingStop = _a.onPinchingStop, onZoomStop = _a.onZoomStop;\n            if (_this.pinchStartScale) {\n                handlePinchStop(_this);\n                handleCallback(getContext(_this), event, onPinchingStop);\n                handleCallback(getContext(_this), event, onZoomStop);\n            }\n        };\n        /// ///////\n        // Touch\n        /// ///////\n        this.onTouchPanningStart = function(event) {\n            var disabled = _this.setup.disabled;\n            var onPanningStart = _this.props.onPanningStart;\n            if (disabled) return;\n            var isAllowed = isPanningStartAllowed(_this, event);\n            if (!isAllowed) return;\n            var isDoubleTap = _this.lastTouch && +new Date() - _this.lastTouch < 200;\n            if (isDoubleTap && event.touches.length === 1) {\n                _this.onDoubleClick(event);\n            } else {\n                _this.lastTouch = +new Date();\n                handleCancelAnimation(_this);\n                var touches = event.touches;\n                var isPanningAction = touches.length === 1;\n                var isPinchAction = touches.length === 2;\n                if (isPanningAction) {\n                    handleCancelAnimation(_this);\n                    handlePanningStart(_this, event);\n                    handleCallback(getContext(_this), event, onPanningStart);\n                }\n                if (isPinchAction) {\n                    _this.onPinchStart(event);\n                }\n            }\n        };\n        this.onTouchPanning = function(event) {\n            var disabled = _this.setup.disabled;\n            var onPanning = _this.props.onPanning;\n            if (_this.isPanning && event.touches.length === 1) {\n                if (disabled) return;\n                var isAllowed = isPanningAllowed(_this);\n                if (!isAllowed) return;\n                event.preventDefault();\n                event.stopPropagation();\n                var touch = event.touches[0];\n                handlePanning(_this, touch.clientX, touch.clientY);\n                handleCallback(getContext(_this), event, onPanning);\n            } else if (event.touches.length > 1) {\n                _this.onPinch(event);\n            }\n        };\n        this.onTouchPanningStop = function(event) {\n            _this.onPanningStop(event);\n            _this.onPinchStop(event);\n        };\n        /// ///////\n        // Double Click\n        /// ///////\n        this.onDoubleClick = function(event) {\n            var disabled = _this.setup.disabled;\n            if (disabled) return;\n            var isAllowed = isDoubleClickAllowed(_this, event);\n            if (!isAllowed) return;\n            handleDoubleClick(_this, event);\n        };\n        /// ///////\n        // Helpers\n        /// ///////\n        this.clearPanning = function(event) {\n            if (_this.isPanning) {\n                _this.onPanningStop(event);\n            }\n        };\n        this.setKeyPressed = function(e) {\n            _this.pressedKeys[e.key] = true;\n        };\n        this.setKeyUnPressed = function(e) {\n            _this.pressedKeys[e.key] = false;\n        };\n        this.isPressingKeys = function(keys) {\n            if (!keys.length) {\n                return true;\n            }\n            return Boolean(keys.find(function(key) {\n                return _this.pressedKeys[key];\n            }));\n        };\n        this.setTransformState = function(scale, positionX, positionY) {\n            var onTransformed = _this.props.onTransformed;\n            if (!Number.isNaN(scale) && !Number.isNaN(positionX) && !Number.isNaN(positionY)) {\n                if (scale !== _this.transformState.scale) {\n                    _this.transformState.previousScale = _this.transformState.scale;\n                    _this.transformState.scale = scale;\n                }\n                _this.transformState.positionX = positionX;\n                _this.transformState.positionY = positionY;\n                var ctx_1 = getContext(_this);\n                _this.onChangeCallbacks.forEach(function(callback) {\n                    return callback(ctx_1);\n                });\n                handleCallback(ctx_1, {\n                    scale: scale,\n                    positionX: positionX,\n                    positionY: positionY\n                }, onTransformed);\n                _this.applyTransformation();\n            } else {\n                console.error(\"Detected NaN set state values\");\n            }\n        };\n        this.setCenter = function() {\n            if (_this.wrapperComponent && _this.contentComponent) {\n                var targetState = getCenterPosition(_this.transformState.scale, _this.wrapperComponent, _this.contentComponent);\n                _this.setTransformState(targetState.scale, targetState.positionX, targetState.positionY);\n            }\n        };\n        this.handleTransformStyles = function(x, y, scale) {\n            if (_this.props.customTransform) {\n                return _this.props.customTransform(x, y, scale);\n            }\n            return getTransformStyles(x, y, scale);\n        };\n        this.applyTransformation = function() {\n            if (!_this.mounted || !_this.contentComponent) return;\n            var _a = _this.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n            var transform = _this.handleTransformStyles(positionX, positionY, scale);\n            _this.contentComponent.style.transform = transform;\n        };\n        this.getContext = function() {\n            return getContext(_this);\n        };\n        this.onChange = function(callback) {\n            if (!_this.onChangeCallbacks.has(callback)) {\n                _this.onChangeCallbacks.add(callback);\n            }\n            return function() {\n                _this.onChangeCallbacks.delete(callback);\n            };\n        };\n        /**\n         * Initialization\n         */ this.init = function(wrapperComponent, contentComponent) {\n            _this.cleanupWindowEvents();\n            _this.wrapperComponent = wrapperComponent;\n            _this.contentComponent = contentComponent;\n            handleCalculateBounds(_this, _this.transformState.scale);\n            _this.handleInitializeWrapperEvents(wrapperComponent);\n            _this.handleInitialize(contentComponent);\n            _this.initializeWindowEvents();\n            _this.isInitialized = true;\n            handleCallback(getContext(_this), undefined, _this.props.onInit);\n        };\n        this.props = props;\n        this.setup = createSetup(this.props);\n        this.transformState = createState(this.props);\n    }\n    return ZoomPanPinch;\n}();\nvar Context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(null);\nvar getContent = function(children, ctx) {\n    if (typeof children === \"function\") {\n        return children(ctx);\n    }\n    return children;\n};\nvar TransformWrapper = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(function(props, ref) {\n    var _a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), forceUpdate = _a[1];\n    var children = props.children;\n    var instance = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new ZoomPanPinch(props)).current;\n    var content = getContent(props.children, getContext(instance));\n    var handleOnChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function() {\n        if (typeof children === \"function\") {\n            forceUpdate(function(prev) {\n                return prev + 1;\n            });\n        }\n    }, [\n        children\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, function() {\n        return getContext(instance);\n    }, [\n        instance\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        instance.update(props);\n    }, [\n        instance,\n        props\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        return instance.onChange(handleOnChange);\n    }, [\n        instance,\n        props,\n        handleOnChange\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Context.Provider, {\n        value: instance\n    }, content);\n});\nfunction styleInject(css, ref) {\n    if (ref === void 0) ref = {};\n    var insertAt = ref.insertAt;\n    if (!css || typeof document === \"undefined\") {\n        return;\n    }\n    var head = document.head || document.getElementsByTagName(\"head\")[0];\n    var style = document.createElement(\"style\");\n    style.type = \"text/css\";\n    if (insertAt === \"top\") {\n        if (head.firstChild) {\n            head.insertBefore(style, head.firstChild);\n        } else {\n            head.appendChild(style);\n        }\n    } else {\n        head.appendChild(style);\n    }\n    if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        style.appendChild(document.createTextNode(css));\n    }\n}\nvar css_248z = \".transform-component-module_wrapper__7HFJe {\\n  position: relative;\\n  width: -moz-fit-content;\\n  width: fit-content;\\n  height: -moz-fit-content;\\n  height: fit-content;\\n  overflow: hidden;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -khtml-user-select: none; /* Konqueror HTML */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n.transform-component-module_content__uCDPE {\\n  display: flex;\\n  flex-wrap: wrap;\\n  width: -moz-fit-content;\\n  width: fit-content;\\n  height: -moz-fit-content;\\n  height: fit-content;\\n  margin: 0;\\n  padding: 0;\\n  transform-origin: 0% 0%;\\n}\\n.transform-component-module_content__uCDPE img {\\n  pointer-events: none;\\n}\\n\";\nvar styles = {\n    \"wrapper\": \"transform-component-module_wrapper__7HFJe\",\n    \"content\": \"transform-component-module_content__uCDPE\"\n};\nstyleInject(css_248z);\nvar TransformComponent = function(_a) {\n    var children = _a.children, _b = _a.wrapperClass, wrapperClass = _b === void 0 ? \"\" : _b, _c = _a.contentClass, contentClass = _c === void 0 ? \"\" : _c, wrapperStyle = _a.wrapperStyle, contentStyle = _a.contentStyle, _d = _a.wrapperProps, wrapperProps = _d === void 0 ? {} : _d, _e = _a.contentProps, contentProps = _e === void 0 ? {} : _e;\n    var init = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context).init;\n    var wrapperRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var contentRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        var wrapper = wrapperRef.current;\n        var content = contentRef.current;\n        if (wrapper !== null && content !== null && init) {\n            init(wrapper, content);\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", __assign({}, wrapperProps, {\n        ref: wrapperRef,\n        className: \"react-transform-wrapper \".concat(styles.wrapper, \" \").concat(wrapperClass),\n        style: wrapperStyle\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", __assign({}, contentProps, {\n        ref: contentRef,\n        className: \"react-transform-component \".concat(styles.content, \" \").concat(contentClass),\n        style: contentStyle\n    }), children));\n};\nvar useTransformContext = function() {\n    var libraryContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    var _a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(getContext(libraryContext || {})), values = _a[0], setValues = _a[1];\n    if (!libraryContext) {\n        throw new Error(\"Transform context mus be placed inside TransformWrapper\");\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        libraryContext.onChange(function(ref) {\n            setValues(ref);\n        });\n    }, [\n        libraryContext\n    ]);\n    return values;\n};\nvar KeepScale = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(function(props, ref) {\n    var localRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    var instance = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Context);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function() {\n        return instance.onChange(function(ctx) {\n            if (localRef.current) {\n                var positionX = 0;\n                var positionY = 0;\n                localRef.current.style.transform = instance.handleTransformStyles(positionX, positionY, 1 / ctx.state.scale);\n            }\n        });\n    }, [\n        instance\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", __assign({}, props, {\n        ref: mergeRefs([\n            localRef,\n            ref\n        ])\n    }));\n});\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtem9vbS1wYW4tcGluY2gvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXlHO0FBRXpHOzs7Q0FHQyxHQUNELElBQUlPLGNBQWMsU0FBVUMsR0FBRyxFQUFFQyxPQUFPO0lBQ3BDLE9BQU9DLE9BQU9GLElBQUlHLE9BQU8sQ0FBQ0Y7QUFDOUI7QUFDQTs7OztDQUlDLEdBQ0QsSUFBSUcsZ0JBQWdCLFNBQVVKLEdBQUcsRUFBRUssWUFBWTtJQUMzQyxPQUFPLE9BQU9MLFFBQVEsV0FBV0EsTUFBTUs7QUFDM0M7QUFFQSxJQUFJQyxpQkFBaUIsU0FBVUMsT0FBTyxFQUFFQyxLQUFLLEVBQUVDLFFBQVE7SUFDbkQsSUFBSUEsWUFBWSxPQUFPQSxhQUFhLFlBQVk7UUFDNUNBLFNBQVNGLFNBQVNDO0lBQ3RCO0FBQ0o7QUFFQSw4QkFBOEIsR0FDOUIsb0NBQW9DLEdBQ3BDOzs7Q0FHQyxHQUNELElBQUlFLFVBQVUsU0FBVUMsQ0FBQztJQUNyQixPQUFPLENBQUNDLEtBQUtDLEdBQUcsQ0FBQ0YsSUFBSUMsS0FBS0UsRUFBRSxJQUFJLElBQUk7QUFDeEM7QUFDQSxTQUFTO0FBQ1QsSUFBSUMsU0FBUyxTQUFVSixDQUFDO0lBQ3BCLE9BQU9BO0FBQ1g7QUFDQSxrQ0FBa0M7QUFDbEMsSUFBSUssYUFBYSxTQUFVTCxDQUFDO0lBQ3hCLE9BQU9BLElBQUlBO0FBQ2Y7QUFDQSxnQ0FBZ0M7QUFDaEMsSUFBSU0sY0FBYyxTQUFVTixDQUFDO0lBQ3pCLE9BQU9BLElBQUssS0FBSUEsQ0FBQUE7QUFDcEI7QUFDQSxnREFBZ0Q7QUFDaEQsSUFBSU8sZ0JBQWdCLFNBQVVQLENBQUM7SUFDM0IsT0FBT0EsSUFBSSxNQUFNLElBQUlBLElBQUlBLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxJQUFJQSxDQUFBQSxJQUFLQTtBQUNwRDtBQUNBLGtDQUFrQztBQUNsQyxJQUFJUSxjQUFjLFNBQVVSLENBQUM7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QixJQUFJQyxZQUFZO2dCQUNoQjJkLFNBQVN4SyxPQUFPLENBQUN3SCxLQUFLLENBQUNELFNBQVMsR0FBR3RKLFNBQVNvSixxQkFBcUIsQ0FBQ3phLFdBQVdDLFdBQVcsSUFBSXNiLElBQUlqTSxLQUFLLENBQUN2UCxLQUFLO1lBQy9HO1FBQ0o7SUFDSixHQUFHO1FBQUNzUjtLQUFTO0lBQ2IscUJBQU9qViwwREFBbUIsQ0FBQyxPQUFPbVAsU0FBUyxDQUFDLEdBQUdpQyxPQUFPO1FBQUUyRixLQUFLRixVQUFVO1lBQUMySztZQUFVeks7U0FBSTtJQUFFO0FBQzVGO0FBRWlKLENBQ2pKLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2V4Ymljby1ib25pay8uL25vZGVfbW9kdWxlcy9yZWFjdC16b29tLXBhbi1waW5jaC9kaXN0L2luZGV4LmVzbS5qcz80ZDNjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VDYWxsYmFjaywgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlRWZmZWN0LCB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIFJvdW5kcyBudW1iZXIgdG8gZ2l2ZW4gZGVjaW1hbFxuICogZWcuIHJvdW5kTnVtYmVyKDIuMzQzNDMsIDEpID0+IDIuM1xuICovXG52YXIgcm91bmROdW1iZXIgPSBmdW5jdGlvbiAobnVtLCBkZWNpbWFsKSB7XG4gICAgcmV0dXJuIE51bWJlcihudW0udG9GaXhlZChkZWNpbWFsKSk7XG59O1xuLyoqXG4gKiBDaGVja3MgaWYgdmFsdWUgaXMgbnVtYmVyLCBpZiBub3QgaXQgcmV0dXJucyBkZWZhdWx0IHZhbHVlXG4gKiAxIyBlZy4gY2hlY2tJc051bWJlcigyLCAzMCkgPT4gMlxuICogMiMgZWcuIGNoZWNrSXNOdW1iZXIobnVsbCwgMzApID0+IDMwXG4gKi9cbnZhciBjaGVja0lzTnVtYmVyID0gZnVuY3Rpb24gKG51bSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBudW0gPT09IFwibnVtYmVyXCIgPyBudW0gOiBkZWZhdWx0VmFsdWU7XG59O1xuXG52YXIgaGFuZGxlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY29udGV4dCwgZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrICYmIHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrKGNvbnRleHQsIGV2ZW50KTtcbiAgICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wbHVzcGx1cyAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbi8qKlxuICogRnVuY3Rpb25zIHNob3VsZCByZXR1cm4gZGVub21pbmF0b3Igb2YgdGhlIHRhcmdldCB2YWx1ZSwgd2hpY2ggaXMgdGhlIG5leHQgYW5pbWF0aW9uIHN0ZXAuXG4gKiB0IGlzIGEgdmFsdWUgZnJvbSAwIHRvIDEsIHJlZmxlY3RpbmcgdGhlIHBlcmNlbnRhZ2Ugb2YgYW5pbWF0aW9uIHN0YXR1cy5cbiAqL1xudmFyIGVhc2VPdXQgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiAtTWF0aC5jb3ModCAqIE1hdGguUEkpIC8gMiArIDAuNTtcbn07XG4vLyBsaW5lYXJcbnZhciBsaW5lYXIgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0O1xufTtcbi8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcbnZhciBlYXNlSW5RdWFkID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG59O1xuLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcbnZhciBlYXNlT3V0UXVhZCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQgKiAoMiAtIHQpO1xufTtcbi8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxudmFyIGVhc2VJbk91dFF1YWQgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XG59O1xuLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxudmFyIGVhc2VJbkN1YmljID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0O1xufTtcbi8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XG52YXIgZWFzZU91dEN1YmljID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gLS10ICogdCAqIHQgKyAxO1xufTtcbi8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxudmFyIGVhc2VJbk91dEN1YmljID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDE7XG59O1xuLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxudmFyIGVhc2VJblF1YXJ0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdDtcbn07XG4vLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxudmFyIGVhc2VPdXRRdWFydCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIDEgLSAtLXQgKiB0ICogdCAqIHQ7XG59O1xuLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXG52YXIgZWFzZUluT3V0UXVhcnQgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gOCAqIHQgKiB0ICogdCAqIHQgOiAxIC0gOCAqIC0tdCAqIHQgKiB0ICogdDtcbn07XG4vLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XG52YXIgZWFzZUluUXVpbnQgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0ICogdCAqIHQgKiB0ICogdDtcbn07XG4vLyBkZWNlbGVyYXRpbmcgdG8gemVybyB2ZWxvY2l0eVxudmFyIGVhc2VPdXRRdWludCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIDEgKyAtLXQgKiB0ICogdCAqIHQgKiB0O1xufTtcbi8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxudmFyIGVhc2VJbk91dFF1aW50ID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdCA8IDAuNSA/IDE2ICogdCAqIHQgKiB0ICogdCAqIHQgOiAxICsgMTYgKiAtLXQgKiB0ICogdCAqIHQgKiB0O1xufTtcbnZhciBhbmltYXRpb25zID0ge1xuICAgIGVhc2VPdXQ6IGVhc2VPdXQsXG4gICAgbGluZWFyOiBsaW5lYXIsXG4gICAgZWFzZUluUXVhZDogZWFzZUluUXVhZCxcbiAgICBlYXNlT3V0UXVhZDogZWFzZU91dFF1YWQsXG4gICAgZWFzZUluT3V0UXVhZDogZWFzZUluT3V0UXVhZCxcbiAgICBlYXNlSW5DdWJpYzogZWFzZUluQ3ViaWMsXG4gICAgZWFzZU91dEN1YmljOiBlYXNlT3V0Q3ViaWMsXG4gICAgZWFzZUluT3V0Q3ViaWM6IGVhc2VJbk91dEN1YmljLFxuICAgIGVhc2VJblF1YXJ0OiBlYXNlSW5RdWFydCxcbiAgICBlYXNlT3V0UXVhcnQ6IGVhc2VPdXRRdWFydCxcbiAgICBlYXNlSW5PdXRRdWFydDogZWFzZUluT3V0UXVhcnQsXG4gICAgZWFzZUluUXVpbnQ6IGVhc2VJblF1aW50LFxuICAgIGVhc2VPdXRRdWludDogZWFzZU91dFF1aW50LFxuICAgIGVhc2VJbk91dFF1aW50OiBlYXNlSW5PdXRRdWludCxcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXBhcmFtLXJlYXNzaWduICovXG52YXIgaGFuZGxlQ2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoYW5pbWF0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBhbmltYXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uKTtcbiAgICB9XG59O1xudmFyIGhhbmRsZUNhbmNlbEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UpIHtcbiAgICBpZiAoIWNvbnRleHRJbnN0YW5jZS5tb3VudGVkKVxuICAgICAgICByZXR1cm47XG4gICAgaGFuZGxlQ2FuY2VsQW5pbWF0aW9uRnJhbWUoY29udGV4dEluc3RhbmNlLmFuaW1hdGlvbik7XG4gICAgLy8gQ2xlYXIgYW5pbWF0aW9uIHN0YXRlXG4gICAgY29udGV4dEluc3RhbmNlLmFuaW1hdGUgPSBmYWxzZTtcbiAgICBjb250ZXh0SW5zdGFuY2UuYW5pbWF0aW9uID0gbnVsbDtcbiAgICBjb250ZXh0SW5zdGFuY2UudmVsb2NpdHkgPSBudWxsO1xufTtcbmZ1bmN0aW9uIGhhbmRsZVNldHVwQW5pbWF0aW9uKGNvbnRleHRJbnN0YW5jZSwgYW5pbWF0aW9uTmFtZSwgYW5pbWF0aW9uVGltZSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIWNvbnRleHRJbnN0YW5jZS5tb3VudGVkKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHZhciBsYXN0U3RlcCA9IDE7XG4gICAgLy8gaWYgYW5vdGhlciBhbmltYXRpb24gaXMgYWN0aXZlXG4gICAgaGFuZGxlQ2FuY2VsQW5pbWF0aW9uKGNvbnRleHRJbnN0YW5jZSk7XG4gICAgLy8gbmV3IGFuaW1hdGlvblxuICAgIGNvbnRleHRJbnN0YW5jZS5hbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghY29udGV4dEluc3RhbmNlLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVDYW5jZWxBbmltYXRpb25GcmFtZShjb250ZXh0SW5zdGFuY2UuYW5pbWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnJhbWVUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWU7XG4gICAgICAgIHZhciBhbmltYXRpb25Qcm9ncmVzcyA9IGZyYW1lVGltZSAvIGFuaW1hdGlvblRpbWU7XG4gICAgICAgIHZhciBhbmltYXRpb25UeXBlID0gYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXTtcbiAgICAgICAgdmFyIHN0ZXAgPSBhbmltYXRpb25UeXBlKGFuaW1hdGlvblByb2dyZXNzKTtcbiAgICAgICAgaWYgKGZyYW1lVGltZSA+PSBhbmltYXRpb25UaW1lKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhsYXN0U3RlcCk7XG4gICAgICAgICAgICBjb250ZXh0SW5zdGFuY2UuYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZXh0SW5zdGFuY2UuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhzdGVwKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjb250ZXh0SW5zdGFuY2UuYW5pbWF0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNvbnRleHRJbnN0YW5jZS5hbmltYXRpb24pO1xufVxuZnVuY3Rpb24gaXNWYWxpZFRhcmdldFN0YXRlKHRhcmdldFN0YXRlKSB7XG4gICAgdmFyIHNjYWxlID0gdGFyZ2V0U3RhdGUuc2NhbGUsIHBvc2l0aW9uWCA9IHRhcmdldFN0YXRlLnBvc2l0aW9uWCwgcG9zaXRpb25ZID0gdGFyZ2V0U3RhdGUucG9zaXRpb25ZO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oc2NhbGUpIHx8XG4gICAgICAgIE51bWJlci5pc05hTihwb3NpdGlvblgpIHx8XG4gICAgICAgIE51bWJlci5pc05hTihwb3NpdGlvblkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhbmltYXRlKGNvbnRleHRJbnN0YW5jZSwgdGFyZ2V0U3RhdGUsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvbk5hbWUpIHtcbiAgICB2YXIgaXNWYWxpZCA9IGlzVmFsaWRUYXJnZXRTdGF0ZSh0YXJnZXRTdGF0ZSk7XG4gICAgaWYgKCFjb250ZXh0SW5zdGFuY2UubW91bnRlZCB8fCAhaXNWYWxpZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBzZXRUcmFuc2Zvcm1TdGF0ZSA9IGNvbnRleHRJbnN0YW5jZS5zZXRUcmFuc2Zvcm1TdGF0ZTtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUsIHNjYWxlID0gX2Euc2NhbGUsIHBvc2l0aW9uWCA9IF9hLnBvc2l0aW9uWCwgcG9zaXRpb25ZID0gX2EucG9zaXRpb25ZO1xuICAgIHZhciBzY2FsZURpZmYgPSB0YXJnZXRTdGF0ZS5zY2FsZSAtIHNjYWxlO1xuICAgIHZhciBwb3NpdGlvblhEaWZmID0gdGFyZ2V0U3RhdGUucG9zaXRpb25YIC0gcG9zaXRpb25YO1xuICAgIHZhciBwb3NpdGlvbllEaWZmID0gdGFyZ2V0U3RhdGUucG9zaXRpb25ZIC0gcG9zaXRpb25ZO1xuICAgIGlmIChhbmltYXRpb25UaW1lID09PSAwKSB7XG4gICAgICAgIHNldFRyYW5zZm9ybVN0YXRlKHRhcmdldFN0YXRlLnNjYWxlLCB0YXJnZXRTdGF0ZS5wb3NpdGlvblgsIHRhcmdldFN0YXRlLnBvc2l0aW9uWSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhbmltYXRpb24gc3RhcnQgdGltZXN0YW1wXG4gICAgICAgIGhhbmRsZVNldHVwQW5pbWF0aW9uKGNvbnRleHRJbnN0YW5jZSwgYW5pbWF0aW9uTmFtZSwgYW5pbWF0aW9uVGltZSwgZnVuY3Rpb24gKHN0ZXApIHtcbiAgICAgICAgICAgIHZhciBuZXdTY2FsZSA9IHNjYWxlICsgc2NhbGVEaWZmICogc3RlcDtcbiAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvblggPSBwb3NpdGlvblggKyBwb3NpdGlvblhEaWZmICogc3RlcDtcbiAgICAgICAgICAgIHZhciBuZXdQb3NpdGlvblkgPSBwb3NpdGlvblkgKyBwb3NpdGlvbllEaWZmICogc3RlcDtcbiAgICAgICAgICAgIHNldFRyYW5zZm9ybVN0YXRlKG5ld1NjYWxlLCBuZXdQb3NpdGlvblgsIG5ld1Bvc2l0aW9uWSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudHNTaXplcyh3cmFwcGVyQ29tcG9uZW50LCBjb250ZW50Q29tcG9uZW50LCBuZXdTY2FsZSkge1xuICAgIHZhciB3cmFwcGVyV2lkdGggPSB3cmFwcGVyQ29tcG9uZW50Lm9mZnNldFdpZHRoO1xuICAgIHZhciB3cmFwcGVySGVpZ2h0ID0gd3JhcHBlckNvbXBvbmVudC5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRlbnRDb21wb25lbnQub2Zmc2V0V2lkdGg7XG4gICAgdmFyIGNvbnRlbnRIZWlnaHQgPSBjb250ZW50Q29tcG9uZW50Lm9mZnNldEhlaWdodDtcbiAgICB2YXIgbmV3Q29udGVudFdpZHRoID0gY29udGVudFdpZHRoICogbmV3U2NhbGU7XG4gICAgdmFyIG5ld0NvbnRlbnRIZWlnaHQgPSBjb250ZW50SGVpZ2h0ICogbmV3U2NhbGU7XG4gICAgdmFyIG5ld0RpZmZXaWR0aCA9IHdyYXBwZXJXaWR0aCAtIG5ld0NvbnRlbnRXaWR0aDtcbiAgICB2YXIgbmV3RGlmZkhlaWdodCA9IHdyYXBwZXJIZWlnaHQgLSBuZXdDb250ZW50SGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICAgIHdyYXBwZXJXaWR0aDogd3JhcHBlcldpZHRoLFxuICAgICAgICB3cmFwcGVySGVpZ2h0OiB3cmFwcGVySGVpZ2h0LFxuICAgICAgICBuZXdDb250ZW50V2lkdGg6IG5ld0NvbnRlbnRXaWR0aCxcbiAgICAgICAgbmV3RGlmZldpZHRoOiBuZXdEaWZmV2lkdGgsXG4gICAgICAgIG5ld0NvbnRlbnRIZWlnaHQ6IG5ld0NvbnRlbnRIZWlnaHQsXG4gICAgICAgIG5ld0RpZmZIZWlnaHQ6IG5ld0RpZmZIZWlnaHQsXG4gICAgfTtcbn1cbnZhciBnZXRCb3VuZHMgPSBmdW5jdGlvbiAod3JhcHBlcldpZHRoLCBuZXdDb250ZW50V2lkdGgsIGRpZmZXaWR0aCwgd3JhcHBlckhlaWdodCwgbmV3Q29udGVudEhlaWdodCwgZGlmZkhlaWdodCwgY2VudGVyWm9vbWVkT3V0KSB7XG4gICAgdmFyIHNjYWxlV2lkdGhGYWN0b3IgPSB3cmFwcGVyV2lkdGggPiBuZXdDb250ZW50V2lkdGhcbiAgICAgICAgPyBkaWZmV2lkdGggKiAoY2VudGVyWm9vbWVkT3V0ID8gMSA6IDAuNSlcbiAgICAgICAgOiAwO1xuICAgIHZhciBzY2FsZUhlaWdodEZhY3RvciA9IHdyYXBwZXJIZWlnaHQgPiBuZXdDb250ZW50SGVpZ2h0XG4gICAgICAgID8gZGlmZkhlaWdodCAqIChjZW50ZXJab29tZWRPdXQgPyAxIDogMC41KVxuICAgICAgICA6IDA7XG4gICAgdmFyIG1pblBvc2l0aW9uWCA9IHdyYXBwZXJXaWR0aCAtIG5ld0NvbnRlbnRXaWR0aCAtIHNjYWxlV2lkdGhGYWN0b3I7XG4gICAgdmFyIG1heFBvc2l0aW9uWCA9IHNjYWxlV2lkdGhGYWN0b3I7XG4gICAgdmFyIG1pblBvc2l0aW9uWSA9IHdyYXBwZXJIZWlnaHQgLSBuZXdDb250ZW50SGVpZ2h0IC0gc2NhbGVIZWlnaHRGYWN0b3I7XG4gICAgdmFyIG1heFBvc2l0aW9uWSA9IHNjYWxlSGVpZ2h0RmFjdG9yO1xuICAgIHJldHVybiB7IG1pblBvc2l0aW9uWDogbWluUG9zaXRpb25YLCBtYXhQb3NpdGlvblg6IG1heFBvc2l0aW9uWCwgbWluUG9zaXRpb25ZOiBtaW5Qb3NpdGlvblksIG1heFBvc2l0aW9uWTogbWF4UG9zaXRpb25ZIH07XG59O1xudmFyIGNhbGN1bGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIG5ld1NjYWxlKSB7XG4gICAgdmFyIHdyYXBwZXJDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2Uud3JhcHBlckNvbXBvbmVudCwgY29udGVudENvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS5jb250ZW50Q29tcG9uZW50O1xuICAgIHZhciBjZW50ZXJab29tZWRPdXQgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAuY2VudGVyWm9vbWVkT3V0O1xuICAgIGlmICghd3JhcHBlckNvbXBvbmVudCB8fCAhY29udGVudENvbXBvbmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21wb25lbnRzIGFyZSBub3QgbW91bnRlZFwiKTtcbiAgICB9XG4gICAgdmFyIF9hID0gZ2V0Q29tcG9uZW50c1NpemVzKHdyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQsIG5ld1NjYWxlKSwgd3JhcHBlcldpZHRoID0gX2Eud3JhcHBlcldpZHRoLCB3cmFwcGVySGVpZ2h0ID0gX2Eud3JhcHBlckhlaWdodCwgbmV3Q29udGVudFdpZHRoID0gX2EubmV3Q29udGVudFdpZHRoLCBuZXdEaWZmV2lkdGggPSBfYS5uZXdEaWZmV2lkdGgsIG5ld0NvbnRlbnRIZWlnaHQgPSBfYS5uZXdDb250ZW50SGVpZ2h0LCBuZXdEaWZmSGVpZ2h0ID0gX2EubmV3RGlmZkhlaWdodDtcbiAgICB2YXIgYm91bmRzID0gZ2V0Qm91bmRzKHdyYXBwZXJXaWR0aCwgbmV3Q29udGVudFdpZHRoLCBuZXdEaWZmV2lkdGgsIHdyYXBwZXJIZWlnaHQsIG5ld0NvbnRlbnRIZWlnaHQsIG5ld0RpZmZIZWlnaHQsIEJvb2xlYW4oY2VudGVyWm9vbWVkT3V0KSk7XG4gICAgcmV0dXJuIGJvdW5kcztcbn07XG4vKipcbiAqIEtlZXBzIHZhbHVlIGJldHdlZW4gZ2l2ZW4gYm91bmRzLCB1c2VkIGZvciBsaW1pdGluZyB2aWV3IHRvIGdpdmVuIGJvdW5kYXJpZXNcbiAqIDEjIGVnLiBib3VuZExpbWl0ZXIoMiwgMCwgMywgdHJ1ZSkgPT4gMlxuICogMiMgZWcuIGJvdW5kTGltaXRlcig0LCAwLCAzLCB0cnVlKSA9PiAzXG4gKiAzIyBlZy4gYm91bmRMaW1pdGVyKC0yLCAwLCAzLCB0cnVlKSA9PiAwXG4gKiA0IyBlZy4gYm91bmRMaW1pdGVyKDEwLCAwLCAzLCBmYWxzZSkgPT4gMTBcbiAqL1xudmFyIGJvdW5kTGltaXRlciA9IGZ1bmN0aW9uICh2YWx1ZSwgbWluQm91bmQsIG1heEJvdW5kLCBpc0FjdGl2ZSkge1xuICAgIGlmICghaXNBY3RpdmUpXG4gICAgICAgIHJldHVybiByb3VuZE51bWJlcih2YWx1ZSwgMik7XG4gICAgaWYgKHZhbHVlIDwgbWluQm91bmQpXG4gICAgICAgIHJldHVybiByb3VuZE51bWJlcihtaW5Cb3VuZCwgMik7XG4gICAgaWYgKHZhbHVlID4gbWF4Qm91bmQpXG4gICAgICAgIHJldHVybiByb3VuZE51bWJlcihtYXhCb3VuZCwgMik7XG4gICAgcmV0dXJuIHJvdW5kTnVtYmVyKHZhbHVlLCAyKTtcbn07XG52YXIgaGFuZGxlQ2FsY3VsYXRlQm91bmRzID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgbmV3U2NhbGUpIHtcbiAgICB2YXIgYm91bmRzID0gY2FsY3VsYXRlQm91bmRzKGNvbnRleHRJbnN0YW5jZSwgbmV3U2NhbGUpO1xuICAgIC8vIFNhdmUgYm91bmRzXG4gICAgY29udGV4dEluc3RhbmNlLmJvdW5kcyA9IGJvdW5kcztcbiAgICByZXR1cm4gYm91bmRzO1xufTtcbmZ1bmN0aW9uIGdldE1vdXNlQm91bmRlZFBvc2l0aW9uKHBvc2l0aW9uWCwgcG9zaXRpb25ZLCBib3VuZHMsIGxpbWl0VG9Cb3VuZHMsIHBhZGRpbmdWYWx1ZVgsIHBhZGRpbmdWYWx1ZVksIHdyYXBwZXJDb21wb25lbnQpIHtcbiAgICB2YXIgbWluUG9zaXRpb25YID0gYm91bmRzLm1pblBvc2l0aW9uWCwgbWluUG9zaXRpb25ZID0gYm91bmRzLm1pblBvc2l0aW9uWSwgbWF4UG9zaXRpb25YID0gYm91bmRzLm1heFBvc2l0aW9uWCwgbWF4UG9zaXRpb25ZID0gYm91bmRzLm1heFBvc2l0aW9uWTtcbiAgICB2YXIgcGFkZGluZ1ggPSAwO1xuICAgIHZhciBwYWRkaW5nWSA9IDA7XG4gICAgaWYgKHdyYXBwZXJDb21wb25lbnQpIHtcbiAgICAgICAgcGFkZGluZ1ggPSBwYWRkaW5nVmFsdWVYO1xuICAgICAgICBwYWRkaW5nWSA9IHBhZGRpbmdWYWx1ZVk7XG4gICAgfVxuICAgIHZhciB4ID0gYm91bmRMaW1pdGVyKHBvc2l0aW9uWCwgbWluUG9zaXRpb25YIC0gcGFkZGluZ1gsIG1heFBvc2l0aW9uWCArIHBhZGRpbmdYLCBsaW1pdFRvQm91bmRzKTtcbiAgICB2YXIgeSA9IGJvdW5kTGltaXRlcihwb3NpdGlvblksIG1pblBvc2l0aW9uWSAtIHBhZGRpbmdZLCBtYXhQb3NpdGlvblkgKyBwYWRkaW5nWSwgbGltaXRUb0JvdW5kcyk7XG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSB9O1xufVxuXG5mdW5jdGlvbiBoYW5kbGVDYWxjdWxhdGVab29tUG9zaXRpb25zKGNvbnRleHRJbnN0YW5jZSwgbW91c2VYLCBtb3VzZVksIG5ld1NjYWxlLCBib3VuZHMsIGxpbWl0VG9Cb3VuZHMpIHtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUsIHNjYWxlID0gX2Euc2NhbGUsIHBvc2l0aW9uWCA9IF9hLnBvc2l0aW9uWCwgcG9zaXRpb25ZID0gX2EucG9zaXRpb25ZO1xuICAgIHZhciBzY2FsZURpZmZlcmVuY2UgPSBuZXdTY2FsZSAtIHNjYWxlO1xuICAgIGlmICh0eXBlb2YgbW91c2VYICE9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBtb3VzZVkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk1vdXNlIFggYW5kIFkgcG9zaXRpb24gd2VyZSBub3QgcHJvdmlkZWQhXCIpO1xuICAgICAgICByZXR1cm4geyB4OiBwb3NpdGlvblgsIHk6IHBvc2l0aW9uWSB9O1xuICAgIH1cbiAgICB2YXIgY2FsY3VsYXRlZFBvc2l0aW9uWCA9IHBvc2l0aW9uWCAtIG1vdXNlWCAqIHNjYWxlRGlmZmVyZW5jZTtcbiAgICB2YXIgY2FsY3VsYXRlZFBvc2l0aW9uWSA9IHBvc2l0aW9uWSAtIG1vdXNlWSAqIHNjYWxlRGlmZmVyZW5jZTtcbiAgICAvLyBkbyBub3QgbGltaXQgdG8gYm91bmRzIHdoZW4gdGhlcmUgaXMgcGFkZGluZyBhbmltYXRpb24sXG4gICAgLy8gaXQgY2F1c2VzIGFuaW1hdGlvbiBzdHJhbmdlIGJlaGF2aW91clxuICAgIHZhciBuZXdQb3NpdGlvbnMgPSBnZXRNb3VzZUJvdW5kZWRQb3NpdGlvbihjYWxjdWxhdGVkUG9zaXRpb25YLCBjYWxjdWxhdGVkUG9zaXRpb25ZLCBib3VuZHMsIGxpbWl0VG9Cb3VuZHMsIDAsIDAsIG51bGwpO1xuICAgIHJldHVybiBuZXdQb3NpdGlvbnM7XG59XG5mdW5jdGlvbiBjaGVja1pvb21Cb3VuZHMoem9vbSwgbWluU2NhbGUsIG1heFNjYWxlLCB6b29tUGFkZGluZywgZW5hYmxlUGFkZGluZykge1xuICAgIHZhciBzY2FsZVBhZGRpbmcgPSBlbmFibGVQYWRkaW5nID8gem9vbVBhZGRpbmcgOiAwO1xuICAgIHZhciBtaW5TY2FsZVdpdGhQYWRkaW5nID0gbWluU2NhbGUgLSBzY2FsZVBhZGRpbmc7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4obWF4U2NhbGUpICYmIHpvb20gPj0gbWF4U2NhbGUpXG4gICAgICAgIHJldHVybiBtYXhTY2FsZTtcbiAgICBpZiAoIU51bWJlci5pc05hTihtaW5TY2FsZSkgJiYgem9vbSA8PSBtaW5TY2FsZVdpdGhQYWRkaW5nKVxuICAgICAgICByZXR1cm4gbWluU2NhbGVXaXRoUGFkZGluZztcbiAgICByZXR1cm4gem9vbTtcbn1cblxudmFyIGlzUGFubmluZ1N0YXJ0QWxsb3dlZCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgdmFyIGV4Y2x1ZGVkID0gY29udGV4dEluc3RhbmNlLnNldHVwLnBhbm5pbmcuZXhjbHVkZWQ7XG4gICAgdmFyIGlzSW5pdGlhbGl6ZWQgPSBjb250ZXh0SW5zdGFuY2UuaXNJbml0aWFsaXplZCwgd3JhcHBlckNvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS53cmFwcGVyQ29tcG9uZW50O1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIGlzV3JhcHBlckNoaWxkID0gd3JhcHBlckNvbXBvbmVudCA9PT0gbnVsbCB8fCB3cmFwcGVyQ29tcG9uZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3cmFwcGVyQ29tcG9uZW50LmNvbnRhaW5zKHRhcmdldCk7XG4gICAgdmFyIGlzQWxsb3dlZCA9IGlzSW5pdGlhbGl6ZWQgJiYgdGFyZ2V0ICYmIGlzV3JhcHBlckNoaWxkO1xuICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGlzRXhjbHVkZWQgPSBpc0V4Y2x1ZGVkTm9kZSh0YXJnZXQsIGV4Y2x1ZGVkKTtcbiAgICBpZiAoaXNFeGNsdWRlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufTtcbnZhciBpc1Bhbm5pbmdBbGxvd2VkID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSkge1xuICAgIHZhciBpc0luaXRpYWxpemVkID0gY29udGV4dEluc3RhbmNlLmlzSW5pdGlhbGl6ZWQsIGlzUGFubmluZyA9IGNvbnRleHRJbnN0YW5jZS5pc1Bhbm5pbmcsIHNldHVwID0gY29udGV4dEluc3RhbmNlLnNldHVwO1xuICAgIHZhciBkaXNhYmxlZCA9IHNldHVwLnBhbm5pbmcuZGlzYWJsZWQ7XG4gICAgdmFyIGlzQWxsb3dlZCA9IGlzSW5pdGlhbGl6ZWQgJiYgaXNQYW5uaW5nICYmICFkaXNhYmxlZDtcbiAgICBpZiAoIWlzQWxsb3dlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufTtcbnZhciBoYW5kbGVQYW5uaW5nU2V0dXAgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBldmVudCkge1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblk7XG4gICAgY29udGV4dEluc3RhbmNlLmlzUGFubmluZyA9IHRydWU7XG4gICAgLy8gUGFubmluZyB3aXRoIG1vdXNlXG4gICAgdmFyIHggPSBldmVudC5jbGllbnRYO1xuICAgIHZhciB5ID0gZXZlbnQuY2xpZW50WTtcbiAgICBjb250ZXh0SW5zdGFuY2Uuc3RhcnRDb29yZHMgPSB7IHg6IHggLSBwb3NpdGlvblgsIHk6IHkgLSBwb3NpdGlvblkgfTtcbn07XG52YXIgaGFuZGxlVG91Y2hQYW5uaW5nU2V0dXAgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBldmVudCkge1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcztcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUsIHBvc2l0aW9uWCA9IF9hLnBvc2l0aW9uWCwgcG9zaXRpb25ZID0gX2EucG9zaXRpb25ZO1xuICAgIGNvbnRleHRJbnN0YW5jZS5pc1Bhbm5pbmcgPSB0cnVlO1xuICAgIC8vIFBhbm5pbmcgd2l0aCB0b3VjaFxuICAgIHZhciBvbmVGaW5nZXJUb3VjaCA9IHRvdWNoZXMubGVuZ3RoID09PSAxO1xuICAgIGlmIChvbmVGaW5nZXJUb3VjaCkge1xuICAgICAgICB2YXIgeCA9IHRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgdmFyIHkgPSB0b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgICAgIGNvbnRleHRJbnN0YW5jZS5zdGFydENvb3JkcyA9IHsgeDogeCAtIHBvc2l0aW9uWCwgeTogeSAtIHBvc2l0aW9uWSB9O1xuICAgIH1cbn07XG5mdW5jdGlvbiBoYW5kbGVQYW5Ub0JvdW5kcyhjb250ZXh0SW5zdGFuY2UpIHtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUsIHBvc2l0aW9uWCA9IF9hLnBvc2l0aW9uWCwgcG9zaXRpb25ZID0gX2EucG9zaXRpb25ZLCBzY2FsZSA9IF9hLnNjYWxlO1xuICAgIHZhciBfYiA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cCwgZGlzYWJsZWQgPSBfYi5kaXNhYmxlZCwgbGltaXRUb0JvdW5kcyA9IF9iLmxpbWl0VG9Cb3VuZHMsIGNlbnRlclpvb21lZE91dCA9IF9iLmNlbnRlclpvb21lZE91dDtcbiAgICB2YXIgd3JhcHBlckNvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS53cmFwcGVyQ29tcG9uZW50O1xuICAgIGlmIChkaXNhYmxlZCB8fCAhd3JhcHBlckNvbXBvbmVudCB8fCAhY29udGV4dEluc3RhbmNlLmJvdW5kcylcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBfYyA9IGNvbnRleHRJbnN0YW5jZS5ib3VuZHMsIG1heFBvc2l0aW9uWCA9IF9jLm1heFBvc2l0aW9uWCwgbWluUG9zaXRpb25YID0gX2MubWluUG9zaXRpb25YLCBtYXhQb3NpdGlvblkgPSBfYy5tYXhQb3NpdGlvblksIG1pblBvc2l0aW9uWSA9IF9jLm1pblBvc2l0aW9uWTtcbiAgICB2YXIgeENoYW5nZWQgPSBwb3NpdGlvblggPiBtYXhQb3NpdGlvblggfHwgcG9zaXRpb25YIDwgbWluUG9zaXRpb25YO1xuICAgIHZhciB5Q2hhbmdlZCA9IHBvc2l0aW9uWSA+IG1heFBvc2l0aW9uWSB8fCBwb3NpdGlvblkgPCBtaW5Qb3NpdGlvblk7XG4gICAgdmFyIG1vdXNlUG9zWCA9IHBvc2l0aW9uWCA+IG1heFBvc2l0aW9uWFxuICAgICAgICA/IHdyYXBwZXJDb21wb25lbnQub2Zmc2V0V2lkdGhcbiAgICAgICAgOiBjb250ZXh0SW5zdGFuY2Uuc2V0dXAubWluUG9zaXRpb25YIHx8IDA7XG4gICAgdmFyIG1vdXNlUG9zWSA9IHBvc2l0aW9uWSA+IG1heFBvc2l0aW9uWVxuICAgICAgICA/IHdyYXBwZXJDb21wb25lbnQub2Zmc2V0SGVpZ2h0XG4gICAgICAgIDogY29udGV4dEluc3RhbmNlLnNldHVwLm1pblBvc2l0aW9uWSB8fCAwO1xuICAgIHZhciBfZCA9IGhhbmRsZUNhbGN1bGF0ZVpvb21Qb3NpdGlvbnMoY29udGV4dEluc3RhbmNlLCBtb3VzZVBvc1gsIG1vdXNlUG9zWSwgc2NhbGUsIGNvbnRleHRJbnN0YW5jZS5ib3VuZHMsIGxpbWl0VG9Cb3VuZHMgfHwgY2VudGVyWm9vbWVkT3V0KSwgeCA9IF9kLngsIHkgPSBfZC55O1xuICAgIHJldHVybiB7XG4gICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgcG9zaXRpb25YOiB4Q2hhbmdlZCA/IHggOiBwb3NpdGlvblgsXG4gICAgICAgIHBvc2l0aW9uWTogeUNoYW5nZWQgPyB5IDogcG9zaXRpb25ZLFxuICAgIH07XG59XG5mdW5jdGlvbiBoYW5kbGVOZXdQb3NpdGlvbihjb250ZXh0SW5zdGFuY2UsIG5ld1Bvc2l0aW9uWCwgbmV3UG9zaXRpb25ZLCBwYWRkaW5nVmFsdWVYLCBwYWRkaW5nVmFsdWVZKSB7XG4gICAgdmFyIGxpbWl0VG9Cb3VuZHMgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAubGltaXRUb0JvdW5kcztcbiAgICB2YXIgd3JhcHBlckNvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS53cmFwcGVyQ29tcG9uZW50LCBib3VuZHMgPSBjb250ZXh0SW5zdGFuY2UuYm91bmRzO1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZSwgc2NhbGUgPSBfYS5zY2FsZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblk7XG4gICAgaWYgKHdyYXBwZXJDb21wb25lbnQgPT09IG51bGwgfHxcbiAgICAgICAgYm91bmRzID09PSBudWxsIHx8XG4gICAgICAgIChuZXdQb3NpdGlvblggPT09IHBvc2l0aW9uWCAmJiBuZXdQb3NpdGlvblkgPT09IHBvc2l0aW9uWSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgX2IgPSBnZXRNb3VzZUJvdW5kZWRQb3NpdGlvbihuZXdQb3NpdGlvblgsIG5ld1Bvc2l0aW9uWSwgYm91bmRzLCBsaW1pdFRvQm91bmRzLCBwYWRkaW5nVmFsdWVYLCBwYWRkaW5nVmFsdWVZLCB3cmFwcGVyQ29tcG9uZW50KSwgeCA9IF9iLngsIHkgPSBfYi55O1xuICAgIGNvbnRleHRJbnN0YW5jZS5zZXRUcmFuc2Zvcm1TdGF0ZShzY2FsZSwgeCwgeSk7XG59XG52YXIgZ2V0UGFubmluZ0NsaWVudFBvc2l0aW9uID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgY2xpZW50WCwgY2xpZW50WSkge1xuICAgIHZhciBzdGFydENvb3JkcyA9IGNvbnRleHRJbnN0YW5jZS5zdGFydENvb3JkcywgdHJhbnNmb3JtU3RhdGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGU7XG4gICAgdmFyIHBhbm5pbmcgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAucGFubmluZztcbiAgICB2YXIgbG9ja0F4aXNYID0gcGFubmluZy5sb2NrQXhpc1gsIGxvY2tBeGlzWSA9IHBhbm5pbmcubG9ja0F4aXNZO1xuICAgIHZhciBwb3NpdGlvblggPSB0cmFuc2Zvcm1TdGF0ZS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IHRyYW5zZm9ybVN0YXRlLnBvc2l0aW9uWTtcbiAgICBpZiAoIXN0YXJ0Q29vcmRzKSB7XG4gICAgICAgIHJldHVybiB7IHg6IHBvc2l0aW9uWCwgeTogcG9zaXRpb25ZIH07XG4gICAgfVxuICAgIHZhciBtb3VzZVggPSBjbGllbnRYIC0gc3RhcnRDb29yZHMueDtcbiAgICB2YXIgbW91c2VZID0gY2xpZW50WSAtIHN0YXJ0Q29vcmRzLnk7XG4gICAgdmFyIG5ld1Bvc2l0aW9uWCA9IGxvY2tBeGlzWCA/IHBvc2l0aW9uWCA6IG1vdXNlWDtcbiAgICB2YXIgbmV3UG9zaXRpb25ZID0gbG9ja0F4aXNZID8gcG9zaXRpb25ZIDogbW91c2VZO1xuICAgIHJldHVybiB7IHg6IG5ld1Bvc2l0aW9uWCwgeTogbmV3UG9zaXRpb25ZIH07XG59O1xudmFyIGdldFBhZGRpbmdWYWx1ZSA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIHNpemUpIHtcbiAgICB2YXIgc2V0dXAgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAsIHRyYW5zZm9ybVN0YXRlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlO1xuICAgIHZhciBzY2FsZSA9IHRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIHZhciBtaW5TY2FsZSA9IHNldHVwLm1pblNjYWxlLCBkaXNhYmxlUGFkZGluZyA9IHNldHVwLmRpc2FibGVQYWRkaW5nO1xuICAgIGlmIChzaXplID4gMCAmJiBzY2FsZSA+PSBtaW5TY2FsZSAmJiAhZGlzYWJsZVBhZGRpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcblxudmFyIGlzVmVsb2NpdHlDYWxjdWxhdGlvbkFsbG93ZWQgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlKSB7XG4gICAgdmFyIG1vdW50ZWQgPSBjb250ZXh0SW5zdGFuY2UubW91bnRlZDtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQsIHZlbG9jaXR5QW5pbWF0aW9uID0gX2EudmVsb2NpdHlBbmltYXRpb247XG4gICAgdmFyIHNjYWxlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIHZhciBkaXNhYmxlZFZlbG9jaXR5ID0gdmVsb2NpdHlBbmltYXRpb24uZGlzYWJsZWQ7XG4gICAgdmFyIGlzQWxsb3dlZCA9ICFkaXNhYmxlZFZlbG9jaXR5IHx8IHNjYWxlID4gMSB8fCAhZGlzYWJsZWQgfHwgbW91bnRlZDtcbiAgICBpZiAoIWlzQWxsb3dlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufTtcbnZhciBpc1ZlbG9jaXR5QWxsb3dlZCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UpIHtcbiAgICB2YXIgbW91bnRlZCA9IGNvbnRleHRJbnN0YW5jZS5tb3VudGVkLCB2ZWxvY2l0eSA9IGNvbnRleHRJbnN0YW5jZS52ZWxvY2l0eSwgYm91bmRzID0gY29udGV4dEluc3RhbmNlLmJvdW5kcztcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQsIHZlbG9jaXR5QW5pbWF0aW9uID0gX2EudmVsb2NpdHlBbmltYXRpb247XG4gICAgdmFyIHNjYWxlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIHZhciBkaXNhYmxlZFZlbG9jaXR5ID0gdmVsb2NpdHlBbmltYXRpb24uZGlzYWJsZWQ7XG4gICAgdmFyIGlzQWxsb3dlZCA9ICFkaXNhYmxlZFZlbG9jaXR5IHx8IHNjYWxlID4gMSB8fCAhZGlzYWJsZWQgfHwgbW91bnRlZDtcbiAgICBpZiAoIWlzQWxsb3dlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdmVsb2NpdHkgfHwgIWJvdW5kcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGdldFZlbG9jaXR5TW92ZVRpbWUoY29udGV4dEluc3RhbmNlLCB2ZWxvY2l0eSkge1xuICAgIHZhciB2ZWxvY2l0eUFuaW1hdGlvbiA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cC52ZWxvY2l0eUFuaW1hdGlvbjtcbiAgICB2YXIgZXF1YWxUb01vdmUgPSB2ZWxvY2l0eUFuaW1hdGlvbi5lcXVhbFRvTW92ZSwgYW5pbWF0aW9uVGltZSA9IHZlbG9jaXR5QW5pbWF0aW9uLmFuaW1hdGlvblRpbWUsIHNlbnNpdGl2aXR5ID0gdmVsb2NpdHlBbmltYXRpb24uc2Vuc2l0aXZpdHk7XG4gICAgaWYgKGVxdWFsVG9Nb3ZlKSB7XG4gICAgICAgIHJldHVybiBhbmltYXRpb25UaW1lICogdmVsb2NpdHkgKiBzZW5zaXRpdml0eTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvblRpbWU7XG59XG5mdW5jdGlvbiBnZXRWZWxvY2l0eVBvc2l0aW9uKG5ld1Bvc2l0aW9uLCBzdGFydFBvc2l0aW9uLCBjdXJyZW50UG9zaXRpb24sIGlzTG9ja2VkLCBsaW1pdFRvQm91bmRzLCBtaW5Qb3NpdGlvbiwgbWF4UG9zaXRpb24sIG1pblRhcmdldCwgbWF4VGFyZ2V0LCBzdGVwKSB7XG4gICAgaWYgKGxpbWl0VG9Cb3VuZHMpIHtcbiAgICAgICAgaWYgKHN0YXJ0UG9zaXRpb24gPiBtYXhQb3NpdGlvbiAmJiBjdXJyZW50UG9zaXRpb24gPiBtYXhQb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIGNhbGN1bGF0ZWRQb3NpdGlvbiA9IG1heFBvc2l0aW9uICsgKG5ld1Bvc2l0aW9uIC0gbWF4UG9zaXRpb24pICogc3RlcDtcbiAgICAgICAgICAgIGlmIChjYWxjdWxhdGVkUG9zaXRpb24gPiBtYXhUYXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1heFRhcmdldDtcbiAgICAgICAgICAgIGlmIChjYWxjdWxhdGVkUG9zaXRpb24gPCBtYXhQb3NpdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF4UG9zaXRpb247XG4gICAgICAgICAgICByZXR1cm4gY2FsY3VsYXRlZFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydFBvc2l0aW9uIDwgbWluUG9zaXRpb24gJiYgY3VycmVudFBvc2l0aW9uIDwgbWluUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHZhciBjYWxjdWxhdGVkUG9zaXRpb24gPSBtaW5Qb3NpdGlvbiArIChuZXdQb3NpdGlvbiAtIG1pblBvc2l0aW9uKSAqIHN0ZXA7XG4gICAgICAgICAgICBpZiAoY2FsY3VsYXRlZFBvc2l0aW9uIDwgbWluVGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiBtaW5UYXJnZXQ7XG4gICAgICAgICAgICBpZiAoY2FsY3VsYXRlZFBvc2l0aW9uID4gbWluUG9zaXRpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pblBvc2l0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZWRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNMb2NrZWQpXG4gICAgICAgIHJldHVybiBzdGFydFBvc2l0aW9uO1xuICAgIHJldHVybiBib3VuZExpbWl0ZXIobmV3UG9zaXRpb24sIG1pblBvc2l0aW9uLCBtYXhQb3NpdGlvbiwgbGltaXRUb0JvdW5kcyk7XG59XG5cbmZ1bmN0aW9uIGdldFNpemVNdWx0aXBsaWVyKHdyYXBwZXJDb21wb25lbnQsIGVxdWFsVG9Nb3ZlKSB7XG4gICAgdmFyIGRlZmF1bHRNdWx0aXBsaWVyID0gMTtcbiAgICBpZiAoZXF1YWxUb01vdmUpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKGRlZmF1bHRNdWx0aXBsaWVyLCB3cmFwcGVyQ29tcG9uZW50Lm9mZnNldFdpZHRoIC8gd2luZG93LmlubmVyV2lkdGgpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdE11bHRpcGxpZXI7XG59XG5mdW5jdGlvbiBoYW5kbGVDYWxjdWxhdGVWZWxvY2l0eShjb250ZXh0SW5zdGFuY2UsIHBvc2l0aW9uKSB7XG4gICAgdmFyIGlzQWxsb3dlZCA9IGlzVmVsb2NpdHlDYWxjdWxhdGlvbkFsbG93ZWQoY29udGV4dEluc3RhbmNlKTtcbiAgICBpZiAoIWlzQWxsb3dlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsYXN0TW91c2VQb3NpdGlvbiA9IGNvbnRleHRJbnN0YW5jZS5sYXN0TW91c2VQb3NpdGlvbiwgdmVsb2NpdHlUaW1lID0gY29udGV4dEluc3RhbmNlLnZlbG9jaXR5VGltZSwgc2V0dXAgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXA7XG4gICAgdmFyIHdyYXBwZXJDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2Uud3JhcHBlckNvbXBvbmVudDtcbiAgICB2YXIgZXF1YWxUb01vdmUgPSBzZXR1cC52ZWxvY2l0eUFuaW1hdGlvbi5lcXVhbFRvTW92ZTtcbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAobGFzdE1vdXNlUG9zaXRpb24gJiYgdmVsb2NpdHlUaW1lICYmIHdyYXBwZXJDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIHNpemVNdWx0aXBsaWVyID0gZ2V0U2l6ZU11bHRpcGxpZXIod3JhcHBlckNvbXBvbmVudCwgZXF1YWxUb01vdmUpO1xuICAgICAgICB2YXIgZGlzdGFuY2VYID0gcG9zaXRpb24ueCAtIGxhc3RNb3VzZVBvc2l0aW9uLng7XG4gICAgICAgIHZhciBkaXN0YW5jZVkgPSBwb3NpdGlvbi55IC0gbGFzdE1vdXNlUG9zaXRpb24ueTtcbiAgICAgICAgdmFyIHZlbG9jaXR5WCA9IGRpc3RhbmNlWCAvIHNpemVNdWx0aXBsaWVyO1xuICAgICAgICB2YXIgdmVsb2NpdHlZID0gZGlzdGFuY2VZIC8gc2l6ZU11bHRpcGxpZXI7XG4gICAgICAgIHZhciBpbnRlcnZhbCA9IG5vdyAtIHZlbG9jaXR5VGltZTtcbiAgICAgICAgdmFyIHNwZWVkID0gZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZO1xuICAgICAgICB2YXIgdmVsb2NpdHkgPSBNYXRoLnNxcnQoc3BlZWQpIC8gaW50ZXJ2YWw7XG4gICAgICAgIGNvbnRleHRJbnN0YW5jZS52ZWxvY2l0eSA9IHsgdmVsb2NpdHlYOiB2ZWxvY2l0eVgsIHZlbG9jaXR5WTogdmVsb2NpdHlZLCB0b3RhbDogdmVsb2NpdHkgfTtcbiAgICB9XG4gICAgY29udGV4dEluc3RhbmNlLmxhc3RNb3VzZVBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgY29udGV4dEluc3RhbmNlLnZlbG9jaXR5VGltZSA9IG5vdztcbn1cbmZ1bmN0aW9uIGhhbmRsZVZlbG9jaXR5UGFubmluZyhjb250ZXh0SW5zdGFuY2UpIHtcbiAgICB2YXIgdmVsb2NpdHkgPSBjb250ZXh0SW5zdGFuY2UudmVsb2NpdHksIGJvdW5kcyA9IGNvbnRleHRJbnN0YW5jZS5ib3VuZHMsIHNldHVwID0gY29udGV4dEluc3RhbmNlLnNldHVwLCB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQ7XG4gICAgdmFyIGlzQWxsb3dlZCA9IGlzVmVsb2NpdHlBbGxvd2VkKGNvbnRleHRJbnN0YW5jZSk7XG4gICAgaWYgKCFpc0FsbG93ZWQgfHwgIXZlbG9jaXR5IHx8ICFib3VuZHMgfHwgIXdyYXBwZXJDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmVsb2NpdHlYID0gdmVsb2NpdHkudmVsb2NpdHlYLCB2ZWxvY2l0eVkgPSB2ZWxvY2l0eS52ZWxvY2l0eVksIHRvdGFsID0gdmVsb2NpdHkudG90YWw7XG4gICAgdmFyIG1heFBvc2l0aW9uWCA9IGJvdW5kcy5tYXhQb3NpdGlvblgsIG1pblBvc2l0aW9uWCA9IGJvdW5kcy5taW5Qb3NpdGlvblgsIG1heFBvc2l0aW9uWSA9IGJvdW5kcy5tYXhQb3NpdGlvblksIG1pblBvc2l0aW9uWSA9IGJvdW5kcy5taW5Qb3NpdGlvblk7XG4gICAgdmFyIGxpbWl0VG9Cb3VuZHMgPSBzZXR1cC5saW1pdFRvQm91bmRzLCBhbGlnbm1lbnRBbmltYXRpb24gPSBzZXR1cC5hbGlnbm1lbnRBbmltYXRpb247XG4gICAgdmFyIHpvb21BbmltYXRpb24gPSBzZXR1cC56b29tQW5pbWF0aW9uLCBwYW5uaW5nID0gc2V0dXAucGFubmluZztcbiAgICB2YXIgbG9ja0F4aXNZID0gcGFubmluZy5sb2NrQXhpc1ksIGxvY2tBeGlzWCA9IHBhbm5pbmcubG9ja0F4aXNYO1xuICAgIHZhciBhbmltYXRpb25UeXBlID0gem9vbUFuaW1hdGlvbi5hbmltYXRpb25UeXBlO1xuICAgIHZhciBzaXplWCA9IGFsaWdubWVudEFuaW1hdGlvbi5zaXplWCwgc2l6ZVkgPSBhbGlnbm1lbnRBbmltYXRpb24uc2l6ZVksIHZlbG9jaXR5QWxpZ25tZW50VGltZSA9IGFsaWdubWVudEFuaW1hdGlvbi52ZWxvY2l0eUFsaWdubWVudFRpbWU7XG4gICAgdmFyIGFsaWduQW5pbWF0aW9uVGltZSA9IHZlbG9jaXR5QWxpZ25tZW50VGltZTtcbiAgICB2YXIgbW92ZUFuaW1hdGlvblRpbWUgPSBnZXRWZWxvY2l0eU1vdmVUaW1lKGNvbnRleHRJbnN0YW5jZSwgdG90YWwpO1xuICAgIHZhciBmaW5hbEFuaW1hdGlvblRpbWUgPSBNYXRoLm1heChtb3ZlQW5pbWF0aW9uVGltZSwgYWxpZ25BbmltYXRpb25UaW1lKTtcbiAgICB2YXIgcGFkZGluZ1ZhbHVlWCA9IGdldFBhZGRpbmdWYWx1ZShjb250ZXh0SW5zdGFuY2UsIHNpemVYKTtcbiAgICB2YXIgcGFkZGluZ1ZhbHVlWSA9IGdldFBhZGRpbmdWYWx1ZShjb250ZXh0SW5zdGFuY2UsIHNpemVZKTtcbiAgICB2YXIgcGFkZGluZ1ggPSAocGFkZGluZ1ZhbHVlWCAqIHdyYXBwZXJDb21wb25lbnQub2Zmc2V0V2lkdGgpIC8gMTAwO1xuICAgIHZhciBwYWRkaW5nWSA9IChwYWRkaW5nVmFsdWVZICogd3JhcHBlckNvbXBvbmVudC5vZmZzZXRIZWlnaHQpIC8gMTAwO1xuICAgIHZhciBtYXhUYXJnZXRYID0gbWF4UG9zaXRpb25YICsgcGFkZGluZ1g7XG4gICAgdmFyIG1pblRhcmdldFggPSBtaW5Qb3NpdGlvblggLSBwYWRkaW5nWDtcbiAgICB2YXIgbWF4VGFyZ2V0WSA9IG1heFBvc2l0aW9uWSArIHBhZGRpbmdZO1xuICAgIHZhciBtaW5UYXJnZXRZID0gbWluUG9zaXRpb25ZIC0gcGFkZGluZ1k7XG4gICAgdmFyIHN0YXJ0U3RhdGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGU7XG4gICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIGhhbmRsZVNldHVwQW5pbWF0aW9uKGNvbnRleHRJbnN0YW5jZSwgYW5pbWF0aW9uVHlwZSwgZmluYWxBbmltYXRpb25UaW1lLCBmdW5jdGlvbiAoc3RlcCkge1xuICAgICAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUsIHNjYWxlID0gX2Euc2NhbGUsIHBvc2l0aW9uWCA9IF9hLnBvc2l0aW9uWCwgcG9zaXRpb25ZID0gX2EucG9zaXRpb25ZO1xuICAgICAgICB2YXIgZnJhbWVUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydFRpbWU7XG4gICAgICAgIHZhciBhbmltYXRpb25Qcm9ncmVzcyA9IGZyYW1lVGltZSAvIGFsaWduQW5pbWF0aW9uVGltZTtcbiAgICAgICAgdmFyIGFsaWduQW5pbWF0aW9uID0gYW5pbWF0aW9uc1thbGlnbm1lbnRBbmltYXRpb24uYW5pbWF0aW9uVHlwZV07XG4gICAgICAgIHZhciBhbGlnblN0ZXAgPSAxIC0gYWxpZ25BbmltYXRpb24oTWF0aC5taW4oMSwgYW5pbWF0aW9uUHJvZ3Jlc3MpKTtcbiAgICAgICAgdmFyIGN1c3RvbVN0ZXAgPSAxIC0gc3RlcDtcbiAgICAgICAgdmFyIG5ld1Bvc2l0aW9uWCA9IHBvc2l0aW9uWCArIHZlbG9jaXR5WCAqIGN1c3RvbVN0ZXA7XG4gICAgICAgIHZhciBuZXdQb3NpdGlvblkgPSBwb3NpdGlvblkgKyB2ZWxvY2l0eVkgKiBjdXN0b21TdGVwO1xuICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uWCA9IGdldFZlbG9jaXR5UG9zaXRpb24obmV3UG9zaXRpb25YLCBzdGFydFN0YXRlLnBvc2l0aW9uWCwgcG9zaXRpb25YLCBsb2NrQXhpc1gsIGxpbWl0VG9Cb3VuZHMsIG1pblBvc2l0aW9uWCwgbWF4UG9zaXRpb25YLCBtaW5UYXJnZXRYLCBtYXhUYXJnZXRYLCBhbGlnblN0ZXApO1xuICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uWSA9IGdldFZlbG9jaXR5UG9zaXRpb24obmV3UG9zaXRpb25ZLCBzdGFydFN0YXRlLnBvc2l0aW9uWSwgcG9zaXRpb25ZLCBsb2NrQXhpc1ksIGxpbWl0VG9Cb3VuZHMsIG1pblBvc2l0aW9uWSwgbWF4UG9zaXRpb25ZLCBtaW5UYXJnZXRZLCBtYXhUYXJnZXRZLCBhbGlnblN0ZXApO1xuICAgICAgICBpZiAocG9zaXRpb25YICE9PSBuZXdQb3NpdGlvblggfHwgcG9zaXRpb25ZICE9PSBuZXdQb3NpdGlvblkpIHtcbiAgICAgICAgICAgIGNvbnRleHRJbnN0YW5jZS5zZXRUcmFuc2Zvcm1TdGF0ZShzY2FsZSwgY3VycmVudFBvc2l0aW9uWCwgY3VycmVudFBvc2l0aW9uWSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUGFubmluZ1N0YXJ0KGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgc2NhbGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUuc2NhbGU7XG4gICAgaGFuZGxlQ2FuY2VsQW5pbWF0aW9uKGNvbnRleHRJbnN0YW5jZSk7XG4gICAgaGFuZGxlQ2FsY3VsYXRlQm91bmRzKGNvbnRleHRJbnN0YW5jZSwgc2NhbGUpO1xuICAgIGlmICh3aW5kb3cuVG91Y2hFdmVudCAhPT0gdW5kZWZpbmVkICYmIGV2ZW50IGluc3RhbmNlb2YgVG91Y2hFdmVudCkge1xuICAgICAgICBoYW5kbGVUb3VjaFBhbm5pbmdTZXR1cChjb250ZXh0SW5zdGFuY2UsIGV2ZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhhbmRsZVBhbm5pbmdTZXR1cChjb250ZXh0SW5zdGFuY2UsIGV2ZW50KTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVBbGlnblRvQm91bmRzKGNvbnRleHRJbnN0YW5jZSkge1xuICAgIHZhciBzY2FsZSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5zY2FsZTtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAsIG1pblNjYWxlID0gX2EubWluU2NhbGUsIGFsaWdubWVudEFuaW1hdGlvbiA9IF9hLmFsaWdubWVudEFuaW1hdGlvbjtcbiAgICB2YXIgZGlzYWJsZWQgPSBhbGlnbm1lbnRBbmltYXRpb24uZGlzYWJsZWQsIHNpemVYID0gYWxpZ25tZW50QW5pbWF0aW9uLnNpemVYLCBzaXplWSA9IGFsaWdubWVudEFuaW1hdGlvbi5zaXplWSwgYW5pbWF0aW9uVGltZSA9IGFsaWdubWVudEFuaW1hdGlvbi5hbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlID0gYWxpZ25tZW50QW5pbWF0aW9uLmFuaW1hdGlvblR5cGU7XG4gICAgdmFyIGlzRGlzYWJsZWQgPSBkaXNhYmxlZCB8fCBzY2FsZSA8IG1pblNjYWxlIHx8ICghc2l6ZVggJiYgIXNpemVZKTtcbiAgICBpZiAoaXNEaXNhYmxlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciB0YXJnZXRTdGF0ZSA9IGhhbmRsZVBhblRvQm91bmRzKGNvbnRleHRJbnN0YW5jZSk7XG4gICAgaWYgKHRhcmdldFN0YXRlKSB7XG4gICAgICAgIGFuaW1hdGUoY29udGV4dEluc3RhbmNlLCB0YXJnZXRTdGF0ZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlUGFubmluZyhjb250ZXh0SW5zdGFuY2UsIGNsaWVudFgsIGNsaWVudFkpIHtcbiAgICB2YXIgc3RhcnRDb29yZHMgPSBjb250ZXh0SW5zdGFuY2Uuc3RhcnRDb29yZHMsIHNldHVwID0gY29udGV4dEluc3RhbmNlLnNldHVwO1xuICAgIHZhciBfYSA9IHNldHVwLmFsaWdubWVudEFuaW1hdGlvbiwgc2l6ZVggPSBfYS5zaXplWCwgc2l6ZVkgPSBfYS5zaXplWTtcbiAgICBpZiAoIXN0YXJ0Q29vcmRzKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIF9iID0gZ2V0UGFubmluZ0NsaWVudFBvc2l0aW9uKGNvbnRleHRJbnN0YW5jZSwgY2xpZW50WCwgY2xpZW50WSksIHggPSBfYi54LCB5ID0gX2IueTtcbiAgICB2YXIgcGFkZGluZ1ZhbHVlWCA9IGdldFBhZGRpbmdWYWx1ZShjb250ZXh0SW5zdGFuY2UsIHNpemVYKTtcbiAgICB2YXIgcGFkZGluZ1ZhbHVlWSA9IGdldFBhZGRpbmdWYWx1ZShjb250ZXh0SW5zdGFuY2UsIHNpemVZKTtcbiAgICBoYW5kbGVDYWxjdWxhdGVWZWxvY2l0eShjb250ZXh0SW5zdGFuY2UsIHsgeDogeCwgeTogeSB9KTtcbiAgICBoYW5kbGVOZXdQb3NpdGlvbihjb250ZXh0SW5zdGFuY2UsIHgsIHksIHBhZGRpbmdWYWx1ZVgsIHBhZGRpbmdWYWx1ZVkpO1xufVxuZnVuY3Rpb24gaGFuZGxlUGFubmluZ0VuZChjb250ZXh0SW5zdGFuY2UpIHtcbiAgICBpZiAoY29udGV4dEluc3RhbmNlLmlzUGFubmluZykge1xuICAgICAgICB2YXIgdmVsb2NpdHlEaXNhYmxlZCA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cC5wYW5uaW5nLnZlbG9jaXR5RGlzYWJsZWQ7XG4gICAgICAgIHZhciB2ZWxvY2l0eSA9IGNvbnRleHRJbnN0YW5jZS52ZWxvY2l0eSwgd3JhcHBlckNvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS53cmFwcGVyQ29tcG9uZW50LCBjb250ZW50Q29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLmNvbnRlbnRDb21wb25lbnQ7XG4gICAgICAgIGNvbnRleHRJbnN0YW5jZS5pc1Bhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgY29udGV4dEluc3RhbmNlLmFuaW1hdGUgPSBmYWxzZTtcbiAgICAgICAgY29udGV4dEluc3RhbmNlLmFuaW1hdGlvbiA9IG51bGw7XG4gICAgICAgIHZhciB3cmFwcGVyUmVjdCA9IHdyYXBwZXJDb21wb25lbnQgPT09IG51bGwgfHwgd3JhcHBlckNvbXBvbmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogd3JhcHBlckNvbXBvbmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIGNvbnRlbnRSZWN0ID0gY29udGVudENvbXBvbmVudCA9PT0gbnVsbCB8fCBjb250ZW50Q29tcG9uZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZW50Q29tcG9uZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgd3JhcHBlcldpZHRoID0gKHdyYXBwZXJSZWN0ID09PSBudWxsIHx8IHdyYXBwZXJSZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3cmFwcGVyUmVjdC53aWR0aCkgfHwgMDtcbiAgICAgICAgdmFyIHdyYXBwZXJIZWlnaHQgPSAod3JhcHBlclJlY3QgPT09IG51bGwgfHwgd3JhcHBlclJlY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdyYXBwZXJSZWN0LmhlaWdodCkgfHwgMDtcbiAgICAgICAgdmFyIGNvbnRlbnRXaWR0aCA9IChjb250ZW50UmVjdCA9PT0gbnVsbCB8fCBjb250ZW50UmVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGVudFJlY3Qud2lkdGgpIHx8IDA7XG4gICAgICAgIHZhciBjb250ZW50SGVpZ2h0ID0gKGNvbnRlbnRSZWN0ID09PSBudWxsIHx8IGNvbnRlbnRSZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZW50UmVjdC5oZWlnaHQpIHx8IDA7XG4gICAgICAgIHZhciBpc1pvb21lZCA9IHdyYXBwZXJXaWR0aCA8IGNvbnRlbnRXaWR0aCB8fCB3cmFwcGVySGVpZ2h0IDwgY29udGVudEhlaWdodDtcbiAgICAgICAgdmFyIHNob3VsZEFuaW1hdGUgPSAhdmVsb2NpdHlEaXNhYmxlZCAmJiB2ZWxvY2l0eSAmJiAodmVsb2NpdHkgPT09IG51bGwgfHwgdmVsb2NpdHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZlbG9jaXR5LnRvdGFsKSA+IDAuMSAmJiBpc1pvb21lZDtcbiAgICAgICAgaWYgKHNob3VsZEFuaW1hdGUpIHtcbiAgICAgICAgICAgIGhhbmRsZVZlbG9jaXR5UGFubmluZyhjb250ZXh0SW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlQWxpZ25Ub0JvdW5kcyhjb250ZXh0SW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVab29tVG9Qb2ludChjb250ZXh0SW5zdGFuY2UsIHNjYWxlLCBtb3VzZVgsIG1vdXNlWSkge1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cCwgbWluU2NhbGUgPSBfYS5taW5TY2FsZSwgbWF4U2NhbGUgPSBfYS5tYXhTY2FsZSwgbGltaXRUb0JvdW5kcyA9IF9hLmxpbWl0VG9Cb3VuZHM7XG4gICAgdmFyIG5ld1NjYWxlID0gY2hlY2tab29tQm91bmRzKHJvdW5kTnVtYmVyKHNjYWxlLCAyKSwgbWluU2NhbGUsIG1heFNjYWxlLCAwLCBmYWxzZSk7XG4gICAgdmFyIGJvdW5kcyA9IGhhbmRsZUNhbGN1bGF0ZUJvdW5kcyhjb250ZXh0SW5zdGFuY2UsIG5ld1NjYWxlKTtcbiAgICB2YXIgX2IgPSBoYW5kbGVDYWxjdWxhdGVab29tUG9zaXRpb25zKGNvbnRleHRJbnN0YW5jZSwgbW91c2VYLCBtb3VzZVksIG5ld1NjYWxlLCBib3VuZHMsIGxpbWl0VG9Cb3VuZHMpLCB4ID0gX2IueCwgeSA9IF9iLnk7XG4gICAgcmV0dXJuIHsgc2NhbGU6IG5ld1NjYWxlLCBwb3NpdGlvblg6IHgsIHBvc2l0aW9uWTogeSB9O1xufVxuZnVuY3Rpb24gaGFuZGxlQWxpZ25Ub1NjYWxlQm91bmRzKGNvbnRleHRJbnN0YW5jZSwgbW91c2VQb3NpdGlvblgsIG1vdXNlUG9zaXRpb25ZKSB7XG4gICAgdmFyIHNjYWxlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQ7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnNldHVwLCBtaW5TY2FsZSA9IF9hLm1pblNjYWxlLCBsaW1pdFRvQm91bmRzID0gX2EubGltaXRUb0JvdW5kcywgem9vbUFuaW1hdGlvbiA9IF9hLnpvb21BbmltYXRpb247XG4gICAgdmFyIGRpc2FibGVkID0gem9vbUFuaW1hdGlvbi5kaXNhYmxlZCwgYW5pbWF0aW9uVGltZSA9IHpvb21BbmltYXRpb24uYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSA9IHpvb21BbmltYXRpb24uYW5pbWF0aW9uVHlwZTtcbiAgICB2YXIgaXNEaXNhYmxlZCA9IGRpc2FibGVkIHx8IHNjYWxlID49IG1pblNjYWxlO1xuICAgIGlmIChzY2FsZSA+PSAxIHx8IGxpbWl0VG9Cb3VuZHMpIHtcbiAgICAgICAgLy8gZmlyZSBmaXQgdG8gYm91bmRzIGFuaW1hdGlvblxuICAgICAgICBoYW5kbGVBbGlnblRvQm91bmRzKGNvbnRleHRJbnN0YW5jZSk7XG4gICAgfVxuICAgIGlmIChpc0Rpc2FibGVkIHx8ICF3cmFwcGVyQ29tcG9uZW50IHx8ICFjb250ZXh0SW5zdGFuY2UubW91bnRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBtb3VzZVggPSBtb3VzZVBvc2l0aW9uWCB8fCB3cmFwcGVyQ29tcG9uZW50Lm9mZnNldFdpZHRoIC8gMjtcbiAgICB2YXIgbW91c2VZID0gbW91c2VQb3NpdGlvblkgfHwgd3JhcHBlckNvbXBvbmVudC5vZmZzZXRIZWlnaHQgLyAyO1xuICAgIHZhciB0YXJnZXRTdGF0ZSA9IGhhbmRsZVpvb21Ub1BvaW50KGNvbnRleHRJbnN0YW5jZSwgbWluU2NhbGUsIG1vdXNlWCwgbW91c2VZKTtcbiAgICBpZiAodGFyZ2V0U3RhdGUpIHtcbiAgICAgICAgYW5pbWF0ZShjb250ZXh0SW5zdGFuY2UsIHRhcmdldFN0YXRlLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKTtcbiAgICB9XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cblxudmFyIGluaXRpYWxTdGF0ZSA9IHtcbiAgICBwcmV2aW91c1NjYWxlOiAxLFxuICAgIHNjYWxlOiAxLFxuICAgIHBvc2l0aW9uWDogMCxcbiAgICBwb3NpdGlvblk6IDAsXG59O1xudmFyIGluaXRpYWxTZXR1cCA9IHtcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgbWluUG9zaXRpb25YOiBudWxsLFxuICAgIG1heFBvc2l0aW9uWDogbnVsbCxcbiAgICBtaW5Qb3NpdGlvblk6IG51bGwsXG4gICAgbWF4UG9zaXRpb25ZOiBudWxsLFxuICAgIG1pblNjYWxlOiAxLFxuICAgIG1heFNjYWxlOiA4LFxuICAgIGxpbWl0VG9Cb3VuZHM6IHRydWUsXG4gICAgY2VudGVyWm9vbWVkT3V0OiBmYWxzZSxcbiAgICBjZW50ZXJPbkluaXQ6IGZhbHNlLFxuICAgIGRpc2FibGVQYWRkaW5nOiBmYWxzZSxcbiAgICB3aGVlbDoge1xuICAgICAgICBzdGVwOiAwLjIsXG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgd2hlZWxEaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIHRvdWNoUGFkRGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICBhY3RpdmF0aW9uS2V5czogW10sXG4gICAgICAgIGV4Y2x1ZGVkOiBbXSxcbiAgICB9LFxuICAgIHBhbm5pbmc6IHtcbiAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICB2ZWxvY2l0eURpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgbG9ja0F4aXNYOiBmYWxzZSxcbiAgICAgICAgbG9ja0F4aXNZOiBmYWxzZSxcbiAgICAgICAgYWN0aXZhdGlvbktleXM6IFtdLFxuICAgICAgICBleGNsdWRlZDogW10sXG4gICAgfSxcbiAgICBwaW5jaDoge1xuICAgICAgICBzdGVwOiA1LFxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIGV4Y2x1ZGVkOiBbXSxcbiAgICB9LFxuICAgIGRvdWJsZUNsaWNrOiB7XG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgc3RlcDogMC43LFxuICAgICAgICBtb2RlOiBcInpvb21JblwiLFxuICAgICAgICBhbmltYXRpb25UeXBlOiBcImVhc2VPdXRcIixcbiAgICAgICAgYW5pbWF0aW9uVGltZTogMjAwLFxuICAgICAgICBleGNsdWRlZDogW10sXG4gICAgfSxcbiAgICB6b29tQW5pbWF0aW9uOiB7XG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgc2l6ZTogMC40LFxuICAgICAgICBhbmltYXRpb25UaW1lOiAyMDAsXG4gICAgICAgIGFuaW1hdGlvblR5cGU6IFwiZWFzZU91dFwiLFxuICAgIH0sXG4gICAgYWxpZ25tZW50QW5pbWF0aW9uOiB7XG4gICAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgc2l6ZVg6IDEwMCxcbiAgICAgICAgc2l6ZVk6IDEwMCxcbiAgICAgICAgYW5pbWF0aW9uVGltZTogMjAwLFxuICAgICAgICB2ZWxvY2l0eUFsaWdubWVudFRpbWU6IDQwMCxcbiAgICAgICAgYW5pbWF0aW9uVHlwZTogXCJlYXNlT3V0XCIsXG4gICAgfSxcbiAgICB2ZWxvY2l0eUFuaW1hdGlvbjoge1xuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIHNlbnNpdGl2aXR5OiAxLFxuICAgICAgICBhbmltYXRpb25UaW1lOiA0MDAsXG4gICAgICAgIGFuaW1hdGlvblR5cGU6IFwiZWFzZU91dFwiLFxuICAgICAgICBlcXVhbFRvTW92ZTogdHJ1ZSxcbiAgICB9LFxufTtcblxudmFyIGNyZWF0ZVN0YXRlID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByZXZpb3VzU2NhbGU6IChfYSA9IHByb3BzLmluaXRpYWxTY2FsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogaW5pdGlhbFN0YXRlLnNjYWxlLFxuICAgICAgICBzY2FsZTogKF9iID0gcHJvcHMuaW5pdGlhbFNjYWxlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBpbml0aWFsU3RhdGUuc2NhbGUsXG4gICAgICAgIHBvc2l0aW9uWDogKF9jID0gcHJvcHMuaW5pdGlhbFBvc2l0aW9uWCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogaW5pdGlhbFN0YXRlLnBvc2l0aW9uWCxcbiAgICAgICAgcG9zaXRpb25ZOiAoX2QgPSBwcm9wcy5pbml0aWFsUG9zaXRpb25ZKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBpbml0aWFsU3RhdGUucG9zaXRpb25ZLFxuICAgIH07XG59O1xudmFyIGNyZWF0ZVNldHVwID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIG5ld1NldHVwID0gX19hc3NpZ24oe30sIGluaXRpYWxTZXR1cCk7XG4gICAgT2JqZWN0LmtleXMocHJvcHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgdmFsaWRWYWx1ZSA9IHR5cGVvZiBwcm9wc1trZXldICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgICB2YXIgdmFsaWRQYXJhbWV0ZXIgPSB0eXBlb2YgaW5pdGlhbFNldHVwW2tleV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICAgIGlmICh2YWxpZFBhcmFtZXRlciAmJiB2YWxpZFZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgZGF0YVR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5pdGlhbFNldHVwW2tleV0pO1xuICAgICAgICAgICAgdmFyIGlzT2JqZWN0ID0gZGF0YVR5cGUgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG4gICAgICAgICAgICB2YXIgaXNBcnJheSA9IGRhdGFUeXBlID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBuZXdTZXR1cFtrZXldID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGluaXRpYWxTZXR1cFtrZXldKSwgcHJvcHNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgbmV3U2V0dXBba2V5XSA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgaW5pdGlhbFNldHVwW2tleV0sIHRydWUpLCBwcm9wc1trZXldLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1NldHVwW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld1NldHVwO1xufTtcblxudmFyIGhhbmRsZUNhbGN1bGF0ZUJ1dHRvblpvb20gPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBkZWx0YSwgc3RlcCkge1xuICAgIHZhciBzY2FsZSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5zY2FsZTtcbiAgICB2YXIgd3JhcHBlckNvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS53cmFwcGVyQ29tcG9uZW50LCBzZXR1cCA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cDtcbiAgICB2YXIgbWF4U2NhbGUgPSBzZXR1cC5tYXhTY2FsZSwgbWluU2NhbGUgPSBzZXR1cC5taW5TY2FsZSwgem9vbUFuaW1hdGlvbiA9IHNldHVwLnpvb21BbmltYXRpb247XG4gICAgdmFyIHNpemUgPSB6b29tQW5pbWF0aW9uLnNpemU7XG4gICAgaWYgKCF3cmFwcGVyQ29tcG9uZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldyYXBwZXIgaXMgbm90IG1vdW50ZWRcIik7XG4gICAgfVxuICAgIHZhciB0YXJnZXRTY2FsZSA9IHNjYWxlICogTWF0aC5leHAoZGVsdGEgKiBzdGVwKTtcbiAgICB2YXIgbmV3U2NhbGUgPSBjaGVja1pvb21Cb3VuZHMocm91bmROdW1iZXIodGFyZ2V0U2NhbGUsIDMpLCBtaW5TY2FsZSwgbWF4U2NhbGUsIHNpemUsIGZhbHNlKTtcbiAgICByZXR1cm4gbmV3U2NhbGU7XG59O1xuZnVuY3Rpb24gaGFuZGxlWm9vbVRvVmlld0NlbnRlcihjb250ZXh0SW5zdGFuY2UsIGRlbHRhLCBzdGVwLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKSB7XG4gICAgdmFyIHdyYXBwZXJDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2Uud3JhcHBlckNvbXBvbmVudDtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUsIHNjYWxlID0gX2Euc2NhbGUsIHBvc2l0aW9uWCA9IF9hLnBvc2l0aW9uWCwgcG9zaXRpb25ZID0gX2EucG9zaXRpb25ZO1xuICAgIGlmICghd3JhcHBlckNvbXBvbmVudClcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJObyBXcmFwcGVyQ29tcG9uZW50IGZvdW5kXCIpO1xuICAgIHZhciB3cmFwcGVyV2lkdGggPSB3cmFwcGVyQ29tcG9uZW50Lm9mZnNldFdpZHRoO1xuICAgIHZhciB3cmFwcGVySGVpZ2h0ID0gd3JhcHBlckNvbXBvbmVudC5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIG1vdXNlWCA9ICh3cmFwcGVyV2lkdGggLyAyIC0gcG9zaXRpb25YKSAvIHNjYWxlO1xuICAgIHZhciBtb3VzZVkgPSAod3JhcHBlckhlaWdodCAvIDIgLSBwb3NpdGlvblkpIC8gc2NhbGU7XG4gICAgdmFyIG5ld1NjYWxlID0gaGFuZGxlQ2FsY3VsYXRlQnV0dG9uWm9vbShjb250ZXh0SW5zdGFuY2UsIGRlbHRhLCBzdGVwKTtcbiAgICB2YXIgdGFyZ2V0U3RhdGUgPSBoYW5kbGVab29tVG9Qb2ludChjb250ZXh0SW5zdGFuY2UsIG5ld1NjYWxlLCBtb3VzZVgsIG1vdXNlWSk7XG4gICAgaWYgKCF0YXJnZXRTdGF0ZSkge1xuICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkVycm9yIGR1cmluZyB6b29tIGV2ZW50LiBOZXcgdHJhbnNmb3JtYXRpb24gc3RhdGUgd2FzIG5vdCBjYWxjdWxhdGVkLlwiKTtcbiAgICB9XG4gICAgYW5pbWF0ZShjb250ZXh0SW5zdGFuY2UsIHRhcmdldFN0YXRlLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKTtcbn1cbmZ1bmN0aW9uIHJlc2V0VHJhbnNmb3JtYXRpb25zKGNvbnRleHRJbnN0YW5jZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSwgb25SZXNldFRyYW5zZm9ybWF0aW9uKSB7XG4gICAgdmFyIHNldHVwID0gY29udGV4dEluc3RhbmNlLnNldHVwLCB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQ7XG4gICAgdmFyIGxpbWl0VG9Cb3VuZHMgPSBzZXR1cC5saW1pdFRvQm91bmRzO1xuICAgIHZhciBpbml0aWFsVHJhbnNmb3JtYXRpb24gPSBjcmVhdGVTdGF0ZShjb250ZXh0SW5zdGFuY2UucHJvcHMpO1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZSwgc2NhbGUgPSBfYS5zY2FsZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblk7XG4gICAgaWYgKCF3cmFwcGVyQ29tcG9uZW50KVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIG5ld0JvdW5kcyA9IGNhbGN1bGF0ZUJvdW5kcyhjb250ZXh0SW5zdGFuY2UsIGluaXRpYWxUcmFuc2Zvcm1hdGlvbi5zY2FsZSk7XG4gICAgdmFyIGJvdW5kZWRQb3NpdGlvbnMgPSBnZXRNb3VzZUJvdW5kZWRQb3NpdGlvbihpbml0aWFsVHJhbnNmb3JtYXRpb24ucG9zaXRpb25YLCBpbml0aWFsVHJhbnNmb3JtYXRpb24ucG9zaXRpb25ZLCBuZXdCb3VuZHMsIGxpbWl0VG9Cb3VuZHMsIDAsIDAsIHdyYXBwZXJDb21wb25lbnQpO1xuICAgIHZhciBuZXdTdGF0ZSA9IHtcbiAgICAgICAgc2NhbGU6IGluaXRpYWxUcmFuc2Zvcm1hdGlvbi5zY2FsZSxcbiAgICAgICAgcG9zaXRpb25YOiBib3VuZGVkUG9zaXRpb25zLngsXG4gICAgICAgIHBvc2l0aW9uWTogYm91bmRlZFBvc2l0aW9ucy55LFxuICAgIH07XG4gICAgaWYgKHNjYWxlID09PSBpbml0aWFsVHJhbnNmb3JtYXRpb24uc2NhbGUgJiZcbiAgICAgICAgcG9zaXRpb25YID09PSBpbml0aWFsVHJhbnNmb3JtYXRpb24ucG9zaXRpb25YICYmXG4gICAgICAgIHBvc2l0aW9uWSA9PT0gaW5pdGlhbFRyYW5zZm9ybWF0aW9uLnBvc2l0aW9uWSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIG9uUmVzZXRUcmFuc2Zvcm1hdGlvbiA9PT0gbnVsbCB8fCBvblJlc2V0VHJhbnNmb3JtYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uUmVzZXRUcmFuc2Zvcm1hdGlvbigpO1xuICAgIGFuaW1hdGUoY29udGV4dEluc3RhbmNlLCBuZXdTdGF0ZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSk7XG59XG5mdW5jdGlvbiBnZXRPZmZzZXQoZWxlbWVudCwgd3JhcHBlciwgY29udGVudCwgc3RhdGUpIHtcbiAgICB2YXIgb2Zmc2V0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgd3JhcHBlck9mZnNldCA9IHdyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGNvbnRlbnRPZmZzZXQgPSBjb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciB4T2ZmID0gd3JhcHBlck9mZnNldC54ICogc3RhdGUuc2NhbGU7XG4gICAgdmFyIHlPZmYgPSB3cmFwcGVyT2Zmc2V0LnkgKiBzdGF0ZS5zY2FsZTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiAob2Zmc2V0LnggLSBjb250ZW50T2Zmc2V0LnggKyB4T2ZmKSAvIHN0YXRlLnNjYWxlLFxuICAgICAgICB5OiAob2Zmc2V0LnkgLSBjb250ZW50T2Zmc2V0LnkgKyB5T2ZmKSAvIHN0YXRlLnNjYWxlLFxuICAgIH07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVab29tVG9Ob2RlKGNvbnRleHRJbnN0YW5jZSwgbm9kZSwgY3VzdG9tWm9vbSkge1xuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2UuY29udGVudENvbXBvbmVudCwgdHJhbnNmb3JtU3RhdGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGU7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnNldHVwLCBsaW1pdFRvQm91bmRzID0gX2EubGltaXRUb0JvdW5kcywgbWluU2NhbGUgPSBfYS5taW5TY2FsZSwgbWF4U2NhbGUgPSBfYS5tYXhTY2FsZTtcbiAgICBpZiAoIXdyYXBwZXJDb21wb25lbnQgfHwgIWNvbnRlbnRDb21wb25lbnQpXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm1TdGF0ZTtcbiAgICB2YXIgd3JhcHBlclJlY3QgPSB3cmFwcGVyQ29tcG9uZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBub2RlUmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIG5vZGVPZmZzZXQgPSBnZXRPZmZzZXQobm9kZSwgd3JhcHBlckNvbXBvbmVudCwgY29udGVudENvbXBvbmVudCwgdHJhbnNmb3JtU3RhdGUpO1xuICAgIHZhciBub2RlTGVmdCA9IG5vZGVPZmZzZXQueDtcbiAgICB2YXIgbm9kZVRvcCA9IG5vZGVPZmZzZXQueTtcbiAgICB2YXIgbm9kZVdpZHRoID0gbm9kZVJlY3Qud2lkdGggLyB0cmFuc2Zvcm1TdGF0ZS5zY2FsZTtcbiAgICB2YXIgbm9kZUhlaWdodCA9IG5vZGVSZWN0LmhlaWdodCAvIHRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIHZhciBzY2FsZVggPSB3cmFwcGVyQ29tcG9uZW50Lm9mZnNldFdpZHRoIC8gbm9kZVdpZHRoO1xuICAgIHZhciBzY2FsZVkgPSB3cmFwcGVyQ29tcG9uZW50Lm9mZnNldEhlaWdodCAvIG5vZGVIZWlnaHQ7XG4gICAgdmFyIG5ld1NjYWxlID0gY2hlY2tab29tQm91bmRzKGN1c3RvbVpvb20gfHwgTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpLCBtaW5TY2FsZSwgbWF4U2NhbGUsIDAsIGZhbHNlKTtcbiAgICB2YXIgb2Zmc2V0WCA9ICh3cmFwcGVyUmVjdC53aWR0aCAtIG5vZGVXaWR0aCAqIG5ld1NjYWxlKSAvIDI7XG4gICAgdmFyIG9mZnNldFkgPSAod3JhcHBlclJlY3QuaGVpZ2h0IC0gbm9kZUhlaWdodCAqIG5ld1NjYWxlKSAvIDI7XG4gICAgdmFyIG5ld1Bvc2l0aW9uWCA9ICh3cmFwcGVyUmVjdC5sZWZ0IC0gbm9kZUxlZnQpICogbmV3U2NhbGUgKyBvZmZzZXRYO1xuICAgIHZhciBuZXdQb3NpdGlvblkgPSAod3JhcHBlclJlY3QudG9wIC0gbm9kZVRvcCkgKiBuZXdTY2FsZSArIG9mZnNldFk7XG4gICAgdmFyIGJvdW5kcyA9IGNhbGN1bGF0ZUJvdW5kcyhjb250ZXh0SW5zdGFuY2UsIG5ld1NjYWxlKTtcbiAgICB2YXIgX2IgPSBnZXRNb3VzZUJvdW5kZWRQb3NpdGlvbihuZXdQb3NpdGlvblgsIG5ld1Bvc2l0aW9uWSwgYm91bmRzLCBsaW1pdFRvQm91bmRzLCAwLCAwLCB3cmFwcGVyQ29tcG9uZW50KSwgeCA9IF9iLngsIHkgPSBfYi55O1xuICAgIHJldHVybiB7IHBvc2l0aW9uWDogeCwgcG9zaXRpb25ZOiB5LCBzY2FsZTogbmV3U2NhbGUgfTtcbn1cblxudmFyIHpvb21JbiA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0ZXAsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUpIHtcbiAgICAgICAgaWYgKHN0ZXAgPT09IHZvaWQgMCkgeyBzdGVwID0gMC41OyB9XG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lID09PSB2b2lkIDApIHsgYW5pbWF0aW9uVGltZSA9IDMwMDsgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gdm9pZCAwKSB7IGFuaW1hdGlvblR5cGUgPSBcImVhc2VPdXRcIjsgfVxuICAgICAgICBoYW5kbGVab29tVG9WaWV3Q2VudGVyKGNvbnRleHRJbnN0YW5jZSwgMSwgc3RlcCwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSk7XG4gICAgfTtcbn07XG52YXIgem9vbU91dCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0ZXAsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUpIHtcbiAgICAgICAgaWYgKHN0ZXAgPT09IHZvaWQgMCkgeyBzdGVwID0gMC41OyB9XG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lID09PSB2b2lkIDApIHsgYW5pbWF0aW9uVGltZSA9IDMwMDsgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gdm9pZCAwKSB7IGFuaW1hdGlvblR5cGUgPSBcImVhc2VPdXRcIjsgfVxuICAgICAgICBoYW5kbGVab29tVG9WaWV3Q2VudGVyKGNvbnRleHRJbnN0YW5jZSwgLTEsIHN0ZXAsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUpO1xuICAgIH07XG59O1xudmFyIHNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5ld1Bvc2l0aW9uWCwgbmV3UG9zaXRpb25ZLCBuZXdTY2FsZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uVGltZSA9PT0gdm9pZCAwKSB7IGFuaW1hdGlvblRpbWUgPSAzMDA7IH1cbiAgICAgICAgaWYgKGFuaW1hdGlvblR5cGUgPT09IHZvaWQgMCkgeyBhbmltYXRpb25UeXBlID0gXCJlYXNlT3V0XCI7IH1cbiAgICAgICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLCBwb3NpdGlvblggPSBfYS5wb3NpdGlvblgsIHBvc2l0aW9uWSA9IF9hLnBvc2l0aW9uWSwgc2NhbGUgPSBfYS5zY2FsZTtcbiAgICAgICAgdmFyIHdyYXBwZXJDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2Uud3JhcHBlckNvbXBvbmVudCwgY29udGVudENvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS5jb250ZW50Q29tcG9uZW50O1xuICAgICAgICB2YXIgZGlzYWJsZWQgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAuZGlzYWJsZWQ7XG4gICAgICAgIGlmIChkaXNhYmxlZCB8fCAhd3JhcHBlckNvbXBvbmVudCB8fCAhY29udGVudENvbXBvbmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHRhcmdldFN0YXRlID0ge1xuICAgICAgICAgICAgcG9zaXRpb25YOiBOdW1iZXIuaXNOYU4obmV3UG9zaXRpb25YKSA/IHBvc2l0aW9uWCA6IG5ld1Bvc2l0aW9uWCxcbiAgICAgICAgICAgIHBvc2l0aW9uWTogTnVtYmVyLmlzTmFOKG5ld1Bvc2l0aW9uWSkgPyBwb3NpdGlvblkgOiBuZXdQb3NpdGlvblksXG4gICAgICAgICAgICBzY2FsZTogTnVtYmVyLmlzTmFOKG5ld1NjYWxlKSA/IHNjYWxlIDogbmV3U2NhbGUsXG4gICAgICAgIH07XG4gICAgICAgIGFuaW1hdGUoY29udGV4dEluc3RhbmNlLCB0YXJnZXRTdGF0ZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSk7XG4gICAgfTtcbn07XG52YXIgcmVzZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lID09PSB2b2lkIDApIHsgYW5pbWF0aW9uVGltZSA9IDIwMDsgfVxuICAgICAgICBpZiAoYW5pbWF0aW9uVHlwZSA9PT0gdm9pZCAwKSB7IGFuaW1hdGlvblR5cGUgPSBcImVhc2VPdXRcIjsgfVxuICAgICAgICByZXNldFRyYW5zZm9ybWF0aW9ucyhjb250ZXh0SW5zdGFuY2UsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUpO1xuICAgIH07XG59O1xudmFyIGNlbnRlclZpZXcgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzY2FsZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uVGltZSA9PT0gdm9pZCAwKSB7IGFuaW1hdGlvblRpbWUgPSAyMDA7IH1cbiAgICAgICAgaWYgKGFuaW1hdGlvblR5cGUgPT09IHZvaWQgMCkgeyBhbmltYXRpb25UeXBlID0gXCJlYXNlT3V0XCI7IH1cbiAgICAgICAgdmFyIHRyYW5zZm9ybVN0YXRlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLCB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2UuY29udGVudENvbXBvbmVudDtcbiAgICAgICAgaWYgKHdyYXBwZXJDb21wb25lbnQgJiYgY29udGVudENvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldFN0YXRlID0gZ2V0Q2VudGVyUG9zaXRpb24oc2NhbGUgfHwgdHJhbnNmb3JtU3RhdGUuc2NhbGUsIHdyYXBwZXJDb21wb25lbnQsIGNvbnRlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgYW5pbWF0ZShjb250ZXh0SW5zdGFuY2UsIHRhcmdldFN0YXRlLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xudmFyIHpvb21Ub0VsZW1lbnQgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlLCBzY2FsZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uVGltZSA9PT0gdm9pZCAwKSB7IGFuaW1hdGlvblRpbWUgPSA2MDA7IH1cbiAgICAgICAgaWYgKGFuaW1hdGlvblR5cGUgPT09IHZvaWQgMCkgeyBhbmltYXRpb25UeXBlID0gXCJlYXNlT3V0XCI7IH1cbiAgICAgICAgaGFuZGxlQ2FuY2VsQW5pbWF0aW9uKGNvbnRleHRJbnN0YW5jZSk7XG4gICAgICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQ7XG4gICAgICAgIHZhciB0YXJnZXQgPSB0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5vZGUpIDogbm9kZTtcbiAgICAgICAgaWYgKHdyYXBwZXJDb21wb25lbnQgJiYgdGFyZ2V0ICYmIHdyYXBwZXJDb21wb25lbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldFN0YXRlID0gY2FsY3VsYXRlWm9vbVRvTm9kZShjb250ZXh0SW5zdGFuY2UsIHRhcmdldCwgc2NhbGUpO1xuICAgICAgICAgICAgYW5pbWF0ZShjb250ZXh0SW5zdGFuY2UsIHRhcmdldFN0YXRlLCBhbmltYXRpb25UaW1lLCBhbmltYXRpb25UeXBlKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG52YXIgZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbnN0YW5jZTogY29udGV4dEluc3RhbmNlLFxuICAgICAgICBzdGF0ZTogY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLFxuICAgICAgICB6b29tSW46IHpvb21Jbihjb250ZXh0SW5zdGFuY2UpLFxuICAgICAgICB6b29tT3V0OiB6b29tT3V0KGNvbnRleHRJbnN0YW5jZSksXG4gICAgICAgIHNldFRyYW5zZm9ybTogc2V0VHJhbnNmb3JtKGNvbnRleHRJbnN0YW5jZSksXG4gICAgICAgIHJlc2V0VHJhbnNmb3JtOiByZXNldFRyYW5zZm9ybShjb250ZXh0SW5zdGFuY2UpLFxuICAgICAgICBjZW50ZXJWaWV3OiBjZW50ZXJWaWV3KGNvbnRleHRJbnN0YW5jZSksXG4gICAgICAgIHpvb21Ub0VsZW1lbnQ6IHpvb21Ub0VsZW1lbnQoY29udGV4dEluc3RhbmNlKSxcbiAgICB9O1xufTtcblxuLy8gV2Ugd2FudCB0byBtYWtlIGV2ZW50IGxpc3RlbmVycyBub24tcGFzc2l2ZSwgYW5kIHRvIGRvIHNvIGhhdmUgdG8gY2hlY2tcbi8vIHRoYXQgYnJvd3NlcnMgc3VwcG9ydCBFdmVudExpc3RlbmVyT3B0aW9ucyBpbiB0aGUgZmlyc3QgcGxhY2UuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG52YXIgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuZnVuY3Rpb24gbWFrZVBhc3NpdmVFdmVudE9wdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGdldCBwYXNzaXZlKCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgIC8vICAgYXR0ZW1wdHMgdG8gYWNjZXNzIHRoZSBwYXNzaXZlIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHBhc3NpdmVTdXBwb3J0ZWQ7XG4gICAgfVxufVxuXG52YXIgaXNFeGNsdWRlZE5vZGUgPSBmdW5jdGlvbiAobm9kZSwgZXhjbHVkZWQpIHtcbiAgICB2YXIgdGFyZ2V0VGFnTmFtZSA9IG5vZGUudGFnTmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBpc0V4Y2x1ZGVkVGFnID0gZXhjbHVkZWQuZmluZChmdW5jdGlvbiAodGFnKSB7IHJldHVybiB0YWcudG9VcHBlckNhc2UoKSA9PT0gdGFyZ2V0VGFnTmFtZTsgfSk7XG4gICAgaWYgKGlzRXhjbHVkZWRUYWcpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHZhciBpc0V4Y2x1ZGVkQ2xhc3NOYW1lID0gZXhjbHVkZWQuZmluZChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIHJldHVybiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICAgIH0pO1xuICAgIGlmIChpc0V4Y2x1ZGVkQ2xhc3NOYW1lKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xudmFyIGNhbmNlbFRpbWVvdXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG59O1xuXG52YXIgZ2V0VHJhbnNmb3JtU3R5bGVzID0gZnVuY3Rpb24gKHgsIHksIHNjYWxlKSB7XG4gICAgLy8gU3RhbmRhcmQgdHJhbnNsYXRlIHByZXZlbnRzIGJsdXJyeSBzdmcgb24gdGhlIHNhZmFyaVxuICAgIHJldHVybiBcInRyYW5zbGF0ZShcIi5jb25jYXQoeCwgXCJweCwgXCIpLmNvbmNhdCh5LCBcInB4KSBzY2FsZShcIikuY29uY2F0KHNjYWxlLCBcIilcIik7XG59O1xudmFyIGdldE1hdHJpeFRyYW5zZm9ybVN0eWxlcyA9IGZ1bmN0aW9uICh4LCB5LCBzY2FsZSkge1xuICAgIC8vIFRoZSBzaG9ydGhhbmQgZm9yIG1hdHJpeCBkb2VzIG5vdCB3b3JrIGZvciBTYWZhcmkgaGVuY2UgdGhlIG5lZWQgdG8gZXhwbGljaXRseSB1c2UgbWF0cml4M2RcbiAgICAvLyBSZWZlciB0byBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvdHJhbnNmb3JtLWZ1bmN0aW9uL21hdHJpeFxuICAgIHZhciBhID0gc2NhbGU7XG4gICAgdmFyIGIgPSAwO1xuICAgIHZhciBjID0gMDtcbiAgICB2YXIgZCA9IHNjYWxlO1xuICAgIHZhciB0eCA9IHg7XG4gICAgdmFyIHR5ID0geTtcbiAgICByZXR1cm4gXCJtYXRyaXgzZChcIi5jb25jYXQoYSwgXCIsIFwiKS5jb25jYXQoYiwgXCIsIDAsIDAsIFwiKS5jb25jYXQoYywgXCIsIFwiKS5jb25jYXQoZCwgXCIsIDAsIDAsIDAsIDAsIDEsIDAsIFwiKS5jb25jYXQodHgsIFwiLCBcIikuY29uY2F0KHR5LCBcIiwgMCwgMSlcIik7XG59O1xudmFyIGdldENlbnRlclBvc2l0aW9uID0gZnVuY3Rpb24gKHNjYWxlLCB3cmFwcGVyQ29tcG9uZW50LCBjb250ZW50Q29tcG9uZW50KSB7XG4gICAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRlbnRDb21wb25lbnQub2Zmc2V0V2lkdGggKiBzY2FsZTtcbiAgICB2YXIgY29udGVudEhlaWdodCA9IGNvbnRlbnRDb21wb25lbnQub2Zmc2V0SGVpZ2h0ICogc2NhbGU7XG4gICAgdmFyIGNlbnRlclBvc2l0aW9uWCA9ICh3cmFwcGVyQ29tcG9uZW50Lm9mZnNldFdpZHRoIC0gY29udGVudFdpZHRoKSAvIDI7XG4gICAgdmFyIGNlbnRlclBvc2l0aW9uWSA9ICh3cmFwcGVyQ29tcG9uZW50Lm9mZnNldEhlaWdodCAtIGNvbnRlbnRIZWlnaHQpIC8gMjtcbiAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgIHBvc2l0aW9uWDogY2VudGVyUG9zaXRpb25YLFxuICAgICAgICBwb3NpdGlvblk6IGNlbnRlclBvc2l0aW9uWSxcbiAgICB9O1xufTtcblxuZnVuY3Rpb24gbWVyZ2VSZWZzKHJlZnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJlZnMuZm9yRWFjaChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmVmKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxudmFyIGlzV2hlZWxBbGxvd2VkID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAud2hlZWwsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQsIHdoZWVsRGlzYWJsZWQgPSBfYS53aGVlbERpc2FibGVkLCB0b3VjaFBhZERpc2FibGVkID0gX2EudG91Y2hQYWREaXNhYmxlZCwgZXhjbHVkZWQgPSBfYS5leGNsdWRlZDtcbiAgICB2YXIgaXNJbml0aWFsaXplZCA9IGNvbnRleHRJbnN0YW5jZS5pc0luaXRpYWxpemVkLCBpc1Bhbm5pbmcgPSBjb250ZXh0SW5zdGFuY2UuaXNQYW5uaW5nO1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIGlzQWxsb3dlZCA9IGlzSW5pdGlhbGl6ZWQgJiYgIWlzUGFubmluZyAmJiAhZGlzYWJsZWQgJiYgdGFyZ2V0O1xuICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gRXZlbnQgY3RybEtleSBkZXRlY3RzIGlmIHRvdWNocGFkIGFjdGlvbiBpcyBleGVjdXRpbmcgd2hlZWwgb3IgcGluY2ggZ2VzdHVyZVxuICAgIGlmICh3aGVlbERpc2FibGVkICYmICFldmVudC5jdHJsS2V5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHRvdWNoUGFkRGlzYWJsZWQgJiYgZXZlbnQuY3RybEtleSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBpc0V4Y2x1ZGVkID0gaXNFeGNsdWRlZE5vZGUodGFyZ2V0LCBleGNsdWRlZCk7XG4gICAgaWYgKGlzRXhjbHVkZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgZ2V0RGVsdGFZID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5kZWx0YVkgPCAwID8gMSA6IC0xO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn07XG5mdW5jdGlvbiBnZXREZWx0YShldmVudCwgY3VzdG9tRGVsdGEpIHtcbiAgICB2YXIgZGVsdGFZID0gZ2V0RGVsdGFZKGV2ZW50KTtcbiAgICB2YXIgZGVsdGEgPSBjaGVja0lzTnVtYmVyKGN1c3RvbURlbHRhLCBkZWx0YVkpO1xuICAgIHJldHVybiBkZWx0YTtcbn1cbmZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZXZlbnQsIGNvbnRlbnRDb21wb25lbnQsIHNjYWxlKSB7XG4gICAgdmFyIGNvbnRlbnRSZWN0ID0gY29udGVudENvbXBvbmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgbW91c2VYID0gMDtcbiAgICB2YXIgbW91c2VZID0gMDtcbiAgICBpZiAoXCJjbGllbnRYXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgLy8gbW91c2UgcG9zaXRpb24geCwgeSBvdmVyIHdyYXBwZXIgY29tcG9uZW50XG4gICAgICAgIG1vdXNlWCA9IChldmVudC5jbGllbnRYIC0gY29udGVudFJlY3QubGVmdCkgLyBzY2FsZTtcbiAgICAgICAgbW91c2VZID0gKGV2ZW50LmNsaWVudFkgLSBjb250ZW50UmVjdC50b3ApIC8gc2NhbGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgICBtb3VzZVggPSAodG91Y2guY2xpZW50WCAtIGNvbnRlbnRSZWN0LmxlZnQpIC8gc2NhbGU7XG4gICAgICAgIG1vdXNlWSA9ICh0b3VjaC5jbGllbnRZIC0gY29udGVudFJlY3QudG9wKSAvIHNjYWxlO1xuICAgIH1cbiAgICBpZiAoTnVtYmVyLmlzTmFOKG1vdXNlWCkgfHwgTnVtYmVyLmlzTmFOKG1vdXNlWSkpXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBtb3VzZSBvciB0b3VjaCBvZmZzZXQgZm91bmRcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogbW91c2VYLFxuICAgICAgICB5OiBtb3VzZVksXG4gICAgfTtcbn1cbnZhciBoYW5kbGVDYWxjdWxhdGVXaGVlbFpvb20gPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBkZWx0YSwgc3RlcCwgZGlzYWJsZSwgZ2V0VGFyZ2V0KSB7XG4gICAgdmFyIHNjYWxlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIHZhciB3cmFwcGVyQ29tcG9uZW50ID0gY29udGV4dEluc3RhbmNlLndyYXBwZXJDb21wb25lbnQsIHNldHVwID0gY29udGV4dEluc3RhbmNlLnNldHVwO1xuICAgIHZhciBtYXhTY2FsZSA9IHNldHVwLm1heFNjYWxlLCBtaW5TY2FsZSA9IHNldHVwLm1pblNjYWxlLCB6b29tQW5pbWF0aW9uID0gc2V0dXAuem9vbUFuaW1hdGlvbiwgZGlzYWJsZVBhZGRpbmcgPSBzZXR1cC5kaXNhYmxlUGFkZGluZztcbiAgICB2YXIgc2l6ZSA9IHpvb21BbmltYXRpb24uc2l6ZSwgZGlzYWJsZWQgPSB6b29tQW5pbWF0aW9uLmRpc2FibGVkO1xuICAgIGlmICghd3JhcHBlckNvbXBvbmVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcmFwcGVyIGlzIG5vdCBtb3VudGVkXCIpO1xuICAgIH1cbiAgICB2YXIgdGFyZ2V0U2NhbGUgPSBzY2FsZSArIGRlbHRhICogKHNjYWxlIC0gc2NhbGUgKiBzdGVwKSAqIHN0ZXA7XG4gICAgaWYgKGdldFRhcmdldClcbiAgICAgICAgcmV0dXJuIHRhcmdldFNjYWxlO1xuICAgIHZhciBwYWRkaW5nRW5hYmxlZCA9IGRpc2FibGUgPyBmYWxzZSA6ICFkaXNhYmxlZDtcbiAgICB2YXIgbmV3U2NhbGUgPSBjaGVja1pvb21Cb3VuZHMocm91bmROdW1iZXIodGFyZ2V0U2NhbGUsIDMpLCBtaW5TY2FsZSwgbWF4U2NhbGUsIHNpemUsIHBhZGRpbmdFbmFibGVkICYmICFkaXNhYmxlUGFkZGluZyk7XG4gICAgcmV0dXJuIG5ld1NjYWxlO1xufTtcbnZhciBoYW5kbGVXaGVlbFpvb21TdG9wID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgcHJldmlvdXNXaGVlbEV2ZW50ID0gY29udGV4dEluc3RhbmNlLnByZXZpb3VzV2hlZWxFdmVudDtcbiAgICB2YXIgc2NhbGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUuc2NhbGU7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnNldHVwLCBtYXhTY2FsZSA9IF9hLm1heFNjYWxlLCBtaW5TY2FsZSA9IF9hLm1pblNjYWxlO1xuICAgIGlmICghcHJldmlvdXNXaGVlbEV2ZW50KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHNjYWxlIDwgbWF4U2NhbGUgfHwgc2NhbGUgPiBtaW5TY2FsZSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKE1hdGguc2lnbihwcmV2aW91c1doZWVsRXZlbnQuZGVsdGFZKSAhPT0gTWF0aC5zaWduKGV2ZW50LmRlbHRhWSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChwcmV2aW91c1doZWVsRXZlbnQuZGVsdGFZID4gMCAmJiBwcmV2aW91c1doZWVsRXZlbnQuZGVsdGFZIDwgZXZlbnQuZGVsdGFZKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAocHJldmlvdXNXaGVlbEV2ZW50LmRlbHRhWSA8IDAgJiYgcHJldmlvdXNXaGVlbEV2ZW50LmRlbHRhWSA+IGV2ZW50LmRlbHRhWSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKE1hdGguc2lnbihwcmV2aW91c1doZWVsRXZlbnQuZGVsdGFZKSAhPT0gTWF0aC5zaWduKGV2ZW50LmRlbHRhWSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbnZhciBpc1BpbmNoU3RhcnRBbGxvd2VkID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAucGluY2gsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQsIGV4Y2x1ZGVkID0gX2EuZXhjbHVkZWQ7XG4gICAgdmFyIGlzSW5pdGlhbGl6ZWQgPSBjb250ZXh0SW5zdGFuY2UuaXNJbml0aWFsaXplZDtcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIHZhciBpc0FsbG93ZWQgPSBpc0luaXRpYWxpemVkICYmICFkaXNhYmxlZCAmJiB0YXJnZXQ7XG4gICAgaWYgKCFpc0FsbG93ZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgaXNFeGNsdWRlZCA9IGlzRXhjbHVkZWROb2RlKHRhcmdldCwgZXhjbHVkZWQpO1xuICAgIGlmIChpc0V4Y2x1ZGVkKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59O1xudmFyIGlzUGluY2hBbGxvd2VkID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSkge1xuICAgIHZhciBkaXNhYmxlZCA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cC5waW5jaC5kaXNhYmxlZDtcbiAgICB2YXIgaXNJbml0aWFsaXplZCA9IGNvbnRleHRJbnN0YW5jZS5pc0luaXRpYWxpemVkLCBwaW5jaFN0YXJ0RGlzdGFuY2UgPSBjb250ZXh0SW5zdGFuY2UucGluY2hTdGFydERpc3RhbmNlO1xuICAgIHZhciBpc0FsbG93ZWQgPSBpc0luaXRpYWxpemVkICYmICFkaXNhYmxlZCAmJiBwaW5jaFN0YXJ0RGlzdGFuY2U7XG4gICAgaWYgKCFpc0FsbG93ZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgY2FsY3VsYXRlVG91Y2hNaWRQb2ludCA9IGZ1bmN0aW9uIChldmVudCwgc2NhbGUsIGNvbnRlbnRDb21wb25lbnQpIHtcbiAgICB2YXIgY29udGVudFJlY3QgPSBjb250ZW50Q29tcG9uZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcztcbiAgICB2YXIgZmlyc3RQb2ludFggPSByb3VuZE51bWJlcih0b3VjaGVzWzBdLmNsaWVudFggLSBjb250ZW50UmVjdC5sZWZ0LCA1KTtcbiAgICB2YXIgZmlyc3RQb2ludFkgPSByb3VuZE51bWJlcih0b3VjaGVzWzBdLmNsaWVudFkgLSBjb250ZW50UmVjdC50b3AsIDUpO1xuICAgIHZhciBzZWNvbmRQb2ludFggPSByb3VuZE51bWJlcih0b3VjaGVzWzFdLmNsaWVudFggLSBjb250ZW50UmVjdC5sZWZ0LCA1KTtcbiAgICB2YXIgc2Vjb25kUG9pbnRZID0gcm91bmROdW1iZXIodG91Y2hlc1sxXS5jbGllbnRZIC0gY29udGVudFJlY3QudG9wLCA1KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiAoZmlyc3RQb2ludFggKyBzZWNvbmRQb2ludFgpIC8gMiAvIHNjYWxlLFxuICAgICAgICB5OiAoZmlyc3RQb2ludFkgKyBzZWNvbmRQb2ludFkpIC8gMiAvIHNjYWxlLFxuICAgIH07XG59O1xudmFyIGdldFRvdWNoRGlzdGFuY2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KChldmVudC50b3VjaGVzWzBdLnBhZ2VYIC0gZXZlbnQudG91Y2hlc1sxXS5wYWdlWCksIDIpICtcbiAgICAgICAgTWF0aC5wb3coKGV2ZW50LnRvdWNoZXNbMF0ucGFnZVkgLSBldmVudC50b3VjaGVzWzFdLnBhZ2VZKSwgMikpO1xufTtcbnZhciBjYWxjdWxhdGVQaW5jaFpvb20gPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBjdXJyZW50RGlzdGFuY2UpIHtcbiAgICB2YXIgcGluY2hTdGFydFNjYWxlID0gY29udGV4dEluc3RhbmNlLnBpbmNoU3RhcnRTY2FsZSwgcGluY2hTdGFydERpc3RhbmNlID0gY29udGV4dEluc3RhbmNlLnBpbmNoU3RhcnREaXN0YW5jZSwgc2V0dXAgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXA7XG4gICAgdmFyIG1heFNjYWxlID0gc2V0dXAubWF4U2NhbGUsIG1pblNjYWxlID0gc2V0dXAubWluU2NhbGUsIHpvb21BbmltYXRpb24gPSBzZXR1cC56b29tQW5pbWF0aW9uLCBkaXNhYmxlUGFkZGluZyA9IHNldHVwLmRpc2FibGVQYWRkaW5nO1xuICAgIHZhciBzaXplID0gem9vbUFuaW1hdGlvbi5zaXplLCBkaXNhYmxlZCA9IHpvb21BbmltYXRpb24uZGlzYWJsZWQ7XG4gICAgaWYgKCFwaW5jaFN0YXJ0U2NhbGUgfHwgcGluY2hTdGFydERpc3RhbmNlID09PSBudWxsIHx8ICFjdXJyZW50RGlzdGFuY2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGluY2ggdG91Y2hlcyBkaXN0YW5jZSB3YXMgbm90IHByb3ZpZGVkXCIpO1xuICAgIH1cbiAgICBpZiAoY3VycmVudERpc3RhbmNlIDwgMCkge1xuICAgICAgICByZXR1cm4gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIH1cbiAgICB2YXIgdG91Y2hQcm9wb3J0aW9uID0gY3VycmVudERpc3RhbmNlIC8gcGluY2hTdGFydERpc3RhbmNlO1xuICAgIHZhciBzY2FsZURpZmZlcmVuY2UgPSB0b3VjaFByb3BvcnRpb24gKiBwaW5jaFN0YXJ0U2NhbGU7XG4gICAgcmV0dXJuIGNoZWNrWm9vbUJvdW5kcyhyb3VuZE51bWJlcihzY2FsZURpZmZlcmVuY2UsIDIpLCBtaW5TY2FsZSwgbWF4U2NhbGUsIHNpemUsICFkaXNhYmxlZCAmJiAhZGlzYWJsZVBhZGRpbmcpO1xufTtcblxudmFyIHdoZWVsU3RvcEV2ZW50VGltZSA9IDE2MDtcbnZhciB3aGVlbEFuaW1hdGlvblRpbWUgPSAxMDA7XG52YXIgaGFuZGxlV2hlZWxTdGFydCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnByb3BzLCBvbldoZWVsU3RhcnQgPSBfYS5vbldoZWVsU3RhcnQsIG9uWm9vbVN0YXJ0ID0gX2Eub25ab29tU3RhcnQ7XG4gICAgaWYgKCFjb250ZXh0SW5zdGFuY2Uud2hlZWxTdG9wRXZlbnRUaW1lcikge1xuICAgICAgICBoYW5kbGVDYW5jZWxBbmltYXRpb24oY29udGV4dEluc3RhbmNlKTtcbiAgICAgICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChjb250ZXh0SW5zdGFuY2UpLCBldmVudCwgb25XaGVlbFN0YXJ0KTtcbiAgICAgICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChjb250ZXh0SW5zdGFuY2UpLCBldmVudCwgb25ab29tU3RhcnQpO1xuICAgIH1cbn07XG52YXIgaGFuZGxlV2hlZWxab29tID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2UucHJvcHMsIG9uV2hlZWwgPSBfYS5vbldoZWVsLCBvblpvb20gPSBfYS5vblpvb207XG4gICAgdmFyIGNvbnRlbnRDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2UuY29udGVudENvbXBvbmVudCwgc2V0dXAgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAsIHRyYW5zZm9ybVN0YXRlID0gY29udGV4dEluc3RhbmNlLnRyYW5zZm9ybVN0YXRlO1xuICAgIHZhciBzY2FsZSA9IHRyYW5zZm9ybVN0YXRlLnNjYWxlO1xuICAgIHZhciBsaW1pdFRvQm91bmRzID0gc2V0dXAubGltaXRUb0JvdW5kcywgY2VudGVyWm9vbWVkT3V0ID0gc2V0dXAuY2VudGVyWm9vbWVkT3V0LCB6b29tQW5pbWF0aW9uID0gc2V0dXAuem9vbUFuaW1hdGlvbiwgd2hlZWwgPSBzZXR1cC53aGVlbCwgZGlzYWJsZVBhZGRpbmcgPSBzZXR1cC5kaXNhYmxlUGFkZGluZztcbiAgICB2YXIgc2l6ZSA9IHpvb21BbmltYXRpb24uc2l6ZSwgZGlzYWJsZWQgPSB6b29tQW5pbWF0aW9uLmRpc2FibGVkO1xuICAgIHZhciBzdGVwID0gd2hlZWwuc3RlcDtcbiAgICBpZiAoIWNvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50IG5vdCBtb3VudGVkXCIpO1xuICAgIH1cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHZhciBkZWx0YSA9IGdldERlbHRhKGV2ZW50LCBudWxsKTtcbiAgICB2YXIgbmV3U2NhbGUgPSBoYW5kbGVDYWxjdWxhdGVXaGVlbFpvb20oY29udGV4dEluc3RhbmNlLCBkZWx0YSwgc3RlcCwgIWV2ZW50LmN0cmxLZXkpO1xuICAgIC8vIGlmIHNjYWxlIG5vdCBjaGFuZ2VcbiAgICBpZiAoc2NhbGUgPT09IG5ld1NjYWxlKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIGJvdW5kcyA9IGhhbmRsZUNhbGN1bGF0ZUJvdW5kcyhjb250ZXh0SW5zdGFuY2UsIG5ld1NjYWxlKTtcbiAgICB2YXIgbW91c2VQb3NpdGlvbiA9IGdldE1vdXNlUG9zaXRpb24oZXZlbnQsIGNvbnRlbnRDb21wb25lbnQsIHNjYWxlKTtcbiAgICB2YXIgaXNQYWRkaW5nRGlzYWJsZWQgPSBkaXNhYmxlZCB8fCBzaXplID09PSAwIHx8IGNlbnRlclpvb21lZE91dCB8fCBkaXNhYmxlUGFkZGluZztcbiAgICB2YXIgaXNMaW1pdGVkVG9Cb3VuZHMgPSBsaW1pdFRvQm91bmRzICYmIGlzUGFkZGluZ0Rpc2FibGVkO1xuICAgIHZhciBfYiA9IGhhbmRsZUNhbGN1bGF0ZVpvb21Qb3NpdGlvbnMoY29udGV4dEluc3RhbmNlLCBtb3VzZVBvc2l0aW9uLngsIG1vdXNlUG9zaXRpb24ueSwgbmV3U2NhbGUsIGJvdW5kcywgaXNMaW1pdGVkVG9Cb3VuZHMpLCB4ID0gX2IueCwgeSA9IF9iLnk7XG4gICAgY29udGV4dEluc3RhbmNlLnByZXZpb3VzV2hlZWxFdmVudCA9IGV2ZW50O1xuICAgIGNvbnRleHRJbnN0YW5jZS5zZXRUcmFuc2Zvcm1TdGF0ZShuZXdTY2FsZSwgeCwgeSk7XG4gICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChjb250ZXh0SW5zdGFuY2UpLCBldmVudCwgb25XaGVlbCk7XG4gICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChjb250ZXh0SW5zdGFuY2UpLCBldmVudCwgb25ab29tKTtcbn07XG52YXIgaGFuZGxlV2hlZWxTdG9wID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2UucHJvcHMsIG9uV2hlZWxTdG9wID0gX2Eub25XaGVlbFN0b3AsIG9uWm9vbVN0b3AgPSBfYS5vblpvb21TdG9wO1xuICAgIC8vIGZpcmUgYW5pbWF0aW9uXG4gICAgY2FuY2VsVGltZW91dChjb250ZXh0SW5zdGFuY2Uud2hlZWxBbmltYXRpb25UaW1lcik7XG4gICAgY29udGV4dEluc3RhbmNlLndoZWVsQW5pbWF0aW9uVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFjb250ZXh0SW5zdGFuY2UubW91bnRlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaGFuZGxlQWxpZ25Ub1NjYWxlQm91bmRzKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQueCwgZXZlbnQueSk7XG4gICAgICAgIGNvbnRleHRJbnN0YW5jZS53aGVlbEFuaW1hdGlvblRpbWVyID0gbnVsbDtcbiAgICB9LCB3aGVlbEFuaW1hdGlvblRpbWUpO1xuICAgIC8vIFdoZWVsIHN0b3AgZXZlbnRcbiAgICB2YXIgaGFzU3RvcHBlZFpvb21pbmcgPSBoYW5kbGVXaGVlbFpvb21TdG9wKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpO1xuICAgIGlmIChoYXNTdG9wcGVkWm9vbWluZykge1xuICAgICAgICBjYW5jZWxUaW1lb3V0KGNvbnRleHRJbnN0YW5jZS53aGVlbFN0b3BFdmVudFRpbWVyKTtcbiAgICAgICAgY29udGV4dEluc3RhbmNlLndoZWVsU3RvcEV2ZW50VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghY29udGV4dEluc3RhbmNlLm1vdW50ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29udGV4dEluc3RhbmNlLndoZWVsU3RvcEV2ZW50VGltZXIgPSBudWxsO1xuICAgICAgICAgICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChjb250ZXh0SW5zdGFuY2UpLCBldmVudCwgb25XaGVlbFN0b3ApO1xuICAgICAgICAgICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChjb250ZXh0SW5zdGFuY2UpLCBldmVudCwgb25ab29tU3RvcCk7XG4gICAgICAgIH0sIHdoZWVsU3RvcEV2ZW50VGltZSk7XG4gICAgfVxufTtcblxudmFyIGhhbmRsZVBpbmNoU3RhcnQgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBldmVudCkge1xuICAgIHZhciBkaXN0YW5jZSA9IGdldFRvdWNoRGlzdGFuY2UoZXZlbnQpO1xuICAgIGNvbnRleHRJbnN0YW5jZS5waW5jaFN0YXJ0RGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICBjb250ZXh0SW5zdGFuY2UubGFzdERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgY29udGV4dEluc3RhbmNlLnBpbmNoU3RhcnRTY2FsZSA9IGNvbnRleHRJbnN0YW5jZS50cmFuc2Zvcm1TdGF0ZS5zY2FsZTtcbiAgICBjb250ZXh0SW5zdGFuY2UuaXNQYW5uaW5nID0gZmFsc2U7XG4gICAgaGFuZGxlQ2FuY2VsQW5pbWF0aW9uKGNvbnRleHRJbnN0YW5jZSk7XG59O1xudmFyIGhhbmRsZVBpbmNoWm9vbSA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UsIGV2ZW50KSB7XG4gICAgdmFyIGNvbnRlbnRDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2UuY29udGVudENvbXBvbmVudCwgcGluY2hTdGFydERpc3RhbmNlID0gY29udGV4dEluc3RhbmNlLnBpbmNoU3RhcnREaXN0YW5jZTtcbiAgICB2YXIgc2NhbGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUuc2NhbGU7XG4gICAgdmFyIF9hID0gY29udGV4dEluc3RhbmNlLnNldHVwLCBsaW1pdFRvQm91bmRzID0gX2EubGltaXRUb0JvdW5kcywgY2VudGVyWm9vbWVkT3V0ID0gX2EuY2VudGVyWm9vbWVkT3V0LCB6b29tQW5pbWF0aW9uID0gX2Euem9vbUFuaW1hdGlvbjtcbiAgICB2YXIgZGlzYWJsZWQgPSB6b29tQW5pbWF0aW9uLmRpc2FibGVkLCBzaXplID0gem9vbUFuaW1hdGlvbi5zaXplO1xuICAgIC8vIGlmIG9uZSBmaW5nZXIgc3RhcnRzIGZyb20gb3V0c2lkZSBvZiB3cmFwcGVyXG4gICAgaWYgKHBpbmNoU3RhcnREaXN0YW5jZSA9PT0gbnVsbCB8fCAhY29udGVudENvbXBvbmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBtaWRQb2ludCA9IGNhbGN1bGF0ZVRvdWNoTWlkUG9pbnQoZXZlbnQsIHNjYWxlLCBjb250ZW50Q29tcG9uZW50KTtcbiAgICAvLyBpZiB0b3VjaGVzIGdvZXMgb2ZmIG9mIHRoZSB3cmFwcGVyIGVsZW1lbnRcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShtaWRQb2ludC54KSB8fCAhTnVtYmVyLmlzRmluaXRlKG1pZFBvaW50LnkpKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIGN1cnJlbnREaXN0YW5jZSA9IGdldFRvdWNoRGlzdGFuY2UoZXZlbnQpO1xuICAgIHZhciBuZXdTY2FsZSA9IGNhbGN1bGF0ZVBpbmNoWm9vbShjb250ZXh0SW5zdGFuY2UsIGN1cnJlbnREaXN0YW5jZSk7XG4gICAgaWYgKG5ld1NjYWxlID09PSBzY2FsZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciBib3VuZHMgPSBoYW5kbGVDYWxjdWxhdGVCb3VuZHMoY29udGV4dEluc3RhbmNlLCBuZXdTY2FsZSk7XG4gICAgdmFyIGlzUGFkZGluZ0Rpc2FibGVkID0gZGlzYWJsZWQgfHwgc2l6ZSA9PT0gMCB8fCBjZW50ZXJab29tZWRPdXQ7XG4gICAgdmFyIGlzTGltaXRlZFRvQm91bmRzID0gbGltaXRUb0JvdW5kcyAmJiBpc1BhZGRpbmdEaXNhYmxlZDtcbiAgICB2YXIgX2IgPSBoYW5kbGVDYWxjdWxhdGVab29tUG9zaXRpb25zKGNvbnRleHRJbnN0YW5jZSwgbWlkUG9pbnQueCwgbWlkUG9pbnQueSwgbmV3U2NhbGUsIGJvdW5kcywgaXNMaW1pdGVkVG9Cb3VuZHMpLCB4ID0gX2IueCwgeSA9IF9iLnk7XG4gICAgY29udGV4dEluc3RhbmNlLnBpbmNoTWlkcG9pbnQgPSBtaWRQb2ludDtcbiAgICBjb250ZXh0SW5zdGFuY2UubGFzdERpc3RhbmNlID0gY3VycmVudERpc3RhbmNlO1xuICAgIGNvbnRleHRJbnN0YW5jZS5zZXRUcmFuc2Zvcm1TdGF0ZShuZXdTY2FsZSwgeCwgeSk7XG59O1xudmFyIGhhbmRsZVBpbmNoU3RvcCA9IGZ1bmN0aW9uIChjb250ZXh0SW5zdGFuY2UpIHtcbiAgICB2YXIgcGluY2hNaWRwb2ludCA9IGNvbnRleHRJbnN0YW5jZS5waW5jaE1pZHBvaW50O1xuICAgIGNvbnRleHRJbnN0YW5jZS52ZWxvY2l0eSA9IG51bGw7XG4gICAgY29udGV4dEluc3RhbmNlLmxhc3REaXN0YW5jZSA9IG51bGw7XG4gICAgY29udGV4dEluc3RhbmNlLnBpbmNoTWlkcG9pbnQgPSBudWxsO1xuICAgIGNvbnRleHRJbnN0YW5jZS5waW5jaFN0YXJ0U2NhbGUgPSBudWxsO1xuICAgIGNvbnRleHRJbnN0YW5jZS5waW5jaFN0YXJ0RGlzdGFuY2UgPSBudWxsO1xuICAgIGhhbmRsZUFsaWduVG9TY2FsZUJvdW5kcyhjb250ZXh0SW5zdGFuY2UsIHBpbmNoTWlkcG9pbnQgPT09IG51bGwgfHwgcGluY2hNaWRwb2ludCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGluY2hNaWRwb2ludC54LCBwaW5jaE1pZHBvaW50ID09PSBudWxsIHx8IHBpbmNoTWlkcG9pbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBpbmNoTWlkcG9pbnQueSk7XG59O1xuXG52YXIgaGFuZGxlRG91YmxlQ2xpY2tTdG9wID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgb25ab29tU3RvcCA9IGNvbnRleHRJbnN0YW5jZS5wcm9wcy5vblpvb21TdG9wO1xuICAgIHZhciBhbmltYXRpb25UaW1lID0gY29udGV4dEluc3RhbmNlLnNldHVwLmRvdWJsZUNsaWNrLmFuaW1hdGlvblRpbWU7XG4gICAgY2FuY2VsVGltZW91dChjb250ZXh0SW5zdGFuY2UuZG91YmxlQ2xpY2tTdG9wRXZlbnRUaW1lcik7XG4gICAgY29udGV4dEluc3RhbmNlLmRvdWJsZUNsaWNrU3RvcEV2ZW50VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGV4dEluc3RhbmNlLmRvdWJsZUNsaWNrU3RvcEV2ZW50VGltZXIgPSBudWxsO1xuICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KGNvbnRleHRJbnN0YW5jZSksIGV2ZW50LCBvblpvb21TdG9wKTtcbiAgICB9LCBhbmltYXRpb25UaW1lKTtcbn07XG52YXIgaGFuZGxlRG91YmxlQ2xpY2tSZXNldE1vZGUgPSBmdW5jdGlvbiAoY29udGV4dEluc3RhbmNlLCBldmVudCkge1xuICAgIHZhciBfYSA9IGNvbnRleHRJbnN0YW5jZS5wcm9wcywgb25ab29tU3RhcnQgPSBfYS5vblpvb21TdGFydCwgb25ab29tID0gX2Eub25ab29tO1xuICAgIHZhciBfYiA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cC5kb3VibGVDbGljaywgYW5pbWF0aW9uVGltZSA9IF9iLmFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUgPSBfYi5hbmltYXRpb25UeXBlO1xuICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoY29udGV4dEluc3RhbmNlKSwgZXZlbnQsIG9uWm9vbVN0YXJ0KTtcbiAgICByZXNldFRyYW5zZm9ybWF0aW9ucyhjb250ZXh0SW5zdGFuY2UsIGFuaW1hdGlvblRpbWUsIGFuaW1hdGlvblR5cGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoY29udGV4dEluc3RhbmNlKSwgZXZlbnQsIG9uWm9vbSk7XG4gICAgfSk7XG4gICAgaGFuZGxlRG91YmxlQ2xpY2tTdG9wKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpO1xufTtcbmZ1bmN0aW9uIGhhbmRsZURvdWJsZUNsaWNrKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgc2V0dXAgPSBjb250ZXh0SW5zdGFuY2Uuc2V0dXAsIGRvdWJsZUNsaWNrU3RvcEV2ZW50VGltZXIgPSBjb250ZXh0SW5zdGFuY2UuZG91YmxlQ2xpY2tTdG9wRXZlbnRUaW1lciwgdHJhbnNmb3JtU3RhdGUgPSBjb250ZXh0SW5zdGFuY2UudHJhbnNmb3JtU3RhdGUsIGNvbnRlbnRDb21wb25lbnQgPSBjb250ZXh0SW5zdGFuY2UuY29udGVudENvbXBvbmVudDtcbiAgICB2YXIgc2NhbGUgPSB0cmFuc2Zvcm1TdGF0ZS5zY2FsZTtcbiAgICB2YXIgX2EgPSBjb250ZXh0SW5zdGFuY2UucHJvcHMsIG9uWm9vbVN0YXJ0ID0gX2Eub25ab29tU3RhcnQsIG9uWm9vbSA9IF9hLm9uWm9vbTtcbiAgICB2YXIgX2IgPSBzZXR1cC5kb3VibGVDbGljaywgZGlzYWJsZWQgPSBfYi5kaXNhYmxlZCwgbW9kZSA9IF9iLm1vZGUsIHN0ZXAgPSBfYi5zdGVwLCBhbmltYXRpb25UaW1lID0gX2IuYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSA9IF9iLmFuaW1hdGlvblR5cGU7XG4gICAgaWYgKGRpc2FibGVkKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKGRvdWJsZUNsaWNrU3RvcEV2ZW50VGltZXIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAobW9kZSA9PT0gXCJyZXNldFwiKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVEb3VibGVDbGlja1Jlc2V0TW9kZShjb250ZXh0SW5zdGFuY2UsIGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKCFjb250ZW50Q29tcG9uZW50KVxuICAgICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIk5vIENvbnRlbnRDb21wb25lbnQgZm91bmRcIik7XG4gICAgdmFyIGRlbHRhID0gbW9kZSA9PT0gXCJ6b29tT3V0XCIgPyAtMSA6IDE7XG4gICAgdmFyIG5ld1NjYWxlID0gaGFuZGxlQ2FsY3VsYXRlQnV0dG9uWm9vbShjb250ZXh0SW5zdGFuY2UsIGRlbHRhLCBzdGVwKTtcbiAgICAvLyBzdG9wIGV4ZWN1dGlvbiB3aGVuIHNjYWxlIGRpZG4ndCBjaGFuZ2VcbiAgICBpZiAoc2NhbGUgPT09IG5ld1NjYWxlKVxuICAgICAgICByZXR1cm47XG4gICAgaGFuZGxlQ2FsbGJhY2soZ2V0Q29udGV4dChjb250ZXh0SW5zdGFuY2UpLCBldmVudCwgb25ab29tU3RhcnQpO1xuICAgIHZhciBtb3VzZVBvc2l0aW9uID0gZ2V0TW91c2VQb3NpdGlvbihldmVudCwgY29udGVudENvbXBvbmVudCwgc2NhbGUpO1xuICAgIHZhciB0YXJnZXRTdGF0ZSA9IGhhbmRsZVpvb21Ub1BvaW50KGNvbnRleHRJbnN0YW5jZSwgbmV3U2NhbGUsIG1vdXNlUG9zaXRpb24ueCwgbW91c2VQb3NpdGlvbi55KTtcbiAgICBpZiAoIXRhcmdldFN0YXRlKSB7XG4gICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiRXJyb3IgZHVyaW5nIHpvb20gZXZlbnQuIE5ldyB0cmFuc2Zvcm1hdGlvbiBzdGF0ZSB3YXMgbm90IGNhbGN1bGF0ZWQuXCIpO1xuICAgIH1cbiAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KGNvbnRleHRJbnN0YW5jZSksIGV2ZW50LCBvblpvb20pO1xuICAgIGFuaW1hdGUoY29udGV4dEluc3RhbmNlLCB0YXJnZXRTdGF0ZSwgYW5pbWF0aW9uVGltZSwgYW5pbWF0aW9uVHlwZSk7XG4gICAgaGFuZGxlRG91YmxlQ2xpY2tTdG9wKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpO1xufVxudmFyIGlzRG91YmxlQ2xpY2tBbGxvd2VkID0gZnVuY3Rpb24gKGNvbnRleHRJbnN0YW5jZSwgZXZlbnQpIHtcbiAgICB2YXIgaXNJbml0aWFsaXplZCA9IGNvbnRleHRJbnN0YW5jZS5pc0luaXRpYWxpemVkLCBzZXR1cCA9IGNvbnRleHRJbnN0YW5jZS5zZXR1cCwgd3JhcHBlckNvbXBvbmVudCA9IGNvbnRleHRJbnN0YW5jZS53cmFwcGVyQ29tcG9uZW50O1xuICAgIHZhciBfYSA9IHNldHVwLmRvdWJsZUNsaWNrLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBleGNsdWRlZCA9IF9hLmV4Y2x1ZGVkO1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIGlzV3JhcHBlckNoaWxkID0gd3JhcHBlckNvbXBvbmVudCA9PT0gbnVsbCB8fCB3cmFwcGVyQ29tcG9uZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3cmFwcGVyQ29tcG9uZW50LmNvbnRhaW5zKHRhcmdldCk7XG4gICAgdmFyIGlzQWxsb3dlZCA9IGlzSW5pdGlhbGl6ZWQgJiYgdGFyZ2V0ICYmIGlzV3JhcHBlckNoaWxkICYmICFkaXNhYmxlZDtcbiAgICBpZiAoIWlzQWxsb3dlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBpc0V4Y2x1ZGVkID0gaXNFeGNsdWRlZE5vZGUodGFyZ2V0LCBleGNsdWRlZCk7XG4gICAgaWYgKGlzRXhjbHVkZWQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBab29tUGFuUGluY2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWm9vbVBhblBpbmNoKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubW91bnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFja3MgPSBuZXcgU2V0KCk7XG4gICAgICAgIC8vIENvbXBvbmVudHNcbiAgICAgICAgdGhpcy53cmFwcGVyQ29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250ZW50Q29tcG9uZW50ID0gbnVsbDtcbiAgICAgICAgLy8gSW5pdGlhbGl6YXRpb25cbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYm91bmRzID0gbnVsbDtcbiAgICAgICAgLy8gd2hlZWwgaGVscGVyc1xuICAgICAgICB0aGlzLnByZXZpb3VzV2hlZWxFdmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMud2hlZWxTdG9wRXZlbnRUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMud2hlZWxBbmltYXRpb25UaW1lciA9IG51bGw7XG4gICAgICAgIC8vIHBhbm5pbmcgaGVscGVyc1xuICAgICAgICB0aGlzLmlzUGFubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN0YXJ0Q29vcmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0VG91Y2ggPSBudWxsO1xuICAgICAgICAvLyBwaW5jaCBoZWxwZXJzXG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3REaXN0YW5jZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGluY2hTdGFydERpc3RhbmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5waW5jaFN0YXJ0U2NhbGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBpbmNoTWlkcG9pbnQgPSBudWxsO1xuICAgICAgICAvLyBkb3VibGUgY2xpY2sgaGVscGVyc1xuICAgICAgICB0aGlzLmRvdWJsZUNsaWNrU3RvcEV2ZW50VGltZXIgPSBudWxsO1xuICAgICAgICAvLyB2ZWxvY2l0eSBoZWxwZXJzXG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSBudWxsO1xuICAgICAgICB0aGlzLnZlbG9jaXR5VGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdE1vdXNlUG9zaXRpb24gPSBudWxsO1xuICAgICAgICAvLyBhbmltYXRpb25zIGhlbHBlcnNcbiAgICAgICAgdGhpcy5hbmltYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXhCb3VuZHMgPSBudWxsO1xuICAgICAgICAvLyBrZXkgcHJlc3NcbiAgICAgICAgdGhpcy5wcmVzc2VkS2V5cyA9IHt9O1xuICAgICAgICB0aGlzLm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaW5pdGlhbGl6ZVdpbmRvd0V2ZW50cygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jbGVhbnVwV2luZG93RXZlbnRzKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKG5ld1Byb3BzKSB7XG4gICAgICAgICAgICBoYW5kbGVDYWxjdWxhdGVCb3VuZHMoX3RoaXMsIF90aGlzLnRyYW5zZm9ybVN0YXRlLnNjYWxlKTtcbiAgICAgICAgICAgIF90aGlzLnNldHVwID0gY3JlYXRlU2V0dXAobmV3UHJvcHMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemVXaW5kb3dFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgcGFzc2l2ZSA9IG1ha2VQYXNzaXZlRXZlbnRPcHRpb24oKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50RG9jdW1lbnQgPSAoX2EgPSBfdGhpcy53cmFwcGVyQ29tcG9uZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3duZXJEb2N1bWVudDtcbiAgICAgICAgICAgIHZhciBjdXJyZW50V2luZG93ID0gY3VycmVudERvY3VtZW50ID09PSBudWxsIHx8IGN1cnJlbnREb2N1bWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudERvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgICAgICAgLy8gUGFubmluZyBvbiB3aW5kb3cgdG8gYWxsb3cgcGFubmluZyB3aGVuIG1vdXNlIGlzIG91dCBvZiBjb21wb25lbnQgd3JhcHBlclxuICAgICAgICAgICAgY3VycmVudFdpbmRvdyA9PT0gbnVsbCB8fCBjdXJyZW50V2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgX3RoaXMub25QYW5uaW5nU3RhcnQsIHBhc3NpdmUpO1xuICAgICAgICAgICAgY3VycmVudFdpbmRvdyA9PT0gbnVsbCB8fCBjdXJyZW50V2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX3RoaXMub25QYW5uaW5nLCBwYXNzaXZlKTtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3cgPT09IG51bGwgfHwgY3VycmVudFdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBfdGhpcy5vblBhbm5pbmdTdG9wLCBwYXNzaXZlKTtcbiAgICAgICAgICAgIGN1cnJlbnREb2N1bWVudCA9PT0gbnVsbCB8fCBjdXJyZW50RG9jdW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnREb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBfdGhpcy5jbGVhclBhbm5pbmcsIHBhc3NpdmUpO1xuICAgICAgICAgICAgY3VycmVudFdpbmRvdyA9PT0gbnVsbCB8fCBjdXJyZW50V2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCBfdGhpcy5zZXRLZXlVblByZXNzZWQsIHBhc3NpdmUpO1xuICAgICAgICAgICAgY3VycmVudFdpbmRvdyA9PT0gbnVsbCB8fCBjdXJyZW50V2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50V2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIF90aGlzLnNldEtleVByZXNzZWQsIHBhc3NpdmUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNsZWFudXBXaW5kb3dFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIHBhc3NpdmUgPSBtYWtlUGFzc2l2ZUV2ZW50T3B0aW9uKCk7XG4gICAgICAgICAgICB2YXIgY3VycmVudERvY3VtZW50ID0gKF9hID0gX3RoaXMud3JhcHBlckNvbXBvbmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICB2YXIgY3VycmVudFdpbmRvdyA9IGN1cnJlbnREb2N1bWVudCA9PT0gbnVsbCB8fCBjdXJyZW50RG9jdW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnREb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3cgPT09IG51bGwgfHwgY3VycmVudFdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIF90aGlzLm9uUGFubmluZ1N0YXJ0LCBwYXNzaXZlKTtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3cgPT09IG51bGwgfHwgY3VycmVudFdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIF90aGlzLm9uUGFubmluZywgcGFzc2l2ZSk7XG4gICAgICAgICAgICBjdXJyZW50V2luZG93ID09PSBudWxsIHx8IGN1cnJlbnRXaW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgX3RoaXMub25QYW5uaW5nU3RvcCwgcGFzc2l2ZSk7XG4gICAgICAgICAgICBjdXJyZW50RG9jdW1lbnQgPT09IG51bGwgfHwgY3VycmVudERvY3VtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgX3RoaXMuY2xlYXJQYW5uaW5nLCBwYXNzaXZlKTtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3cgPT09IG51bGwgfHwgY3VycmVudFdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgX3RoaXMuc2V0S2V5VW5QcmVzc2VkLCBwYXNzaXZlKTtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3cgPT09IG51bGwgfHwgY3VycmVudFdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBfdGhpcy5zZXRLZXlQcmVzc2VkLCBwYXNzaXZlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIF90aGlzLmNsZWFyUGFubmluZywgcGFzc2l2ZSk7XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxBbmltYXRpb24oX3RoaXMpO1xuICAgICAgICAgICAgKF9iID0gX3RoaXMub2JzZXJ2ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNjb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlSW5pdGlhbGl6ZVdyYXBwZXJFdmVudHMgPSBmdW5jdGlvbiAod3JhcHBlcikge1xuICAgICAgICAgICAgLy8gWm9vbWluZyBldmVudHMgb24gd3JhcHBlclxuICAgICAgICAgICAgdmFyIHBhc3NpdmUgPSBtYWtlUGFzc2l2ZUV2ZW50T3B0aW9uKCk7XG4gICAgICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBfdGhpcy5vbldoZWVsWm9vbSwgcGFzc2l2ZSk7XG4gICAgICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJkYmxjbGlja1wiLCBfdGhpcy5vbkRvdWJsZUNsaWNrLCBwYXNzaXZlKTtcbiAgICAgICAgICAgIHdyYXBwZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgX3RoaXMub25Ub3VjaFBhbm5pbmdTdGFydCwgcGFzc2l2ZSk7XG4gICAgICAgICAgICB3cmFwcGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgX3RoaXMub25Ub3VjaFBhbm5pbmcsIHBhc3NpdmUpO1xuICAgICAgICAgICAgd3JhcHBlci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgX3RoaXMub25Ub3VjaFBhbm5pbmdTdG9wLCBwYXNzaXZlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVJbml0aWFsaXplID0gZnVuY3Rpb24gKGNvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHZhciBjZW50ZXJPbkluaXQgPSBfdGhpcy5zZXR1cC5jZW50ZXJPbkluaXQ7XG4gICAgICAgICAgICBfdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uKCk7XG4gICAgICAgICAgICBpZiAoY2VudGVyT25Jbml0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0Q2VudGVyKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMub2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldENlbnRlcigpO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy5vYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBvYnNlcnZpbmcgdGhlIHRhcmdldCBub2RlIGZvciBjb25maWd1cmVkIG11dGF0aW9uc1xuICAgICAgICAgICAgICAgIF90aGlzLm9ic2VydmVyLm9ic2VydmUoY29udGVudENvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vLyAvLy8vLy8vXG4gICAgICAgIC8vIFpvb21cbiAgICAgICAgLy8vIC8vLy8vLy9cbiAgICAgICAgdGhpcy5vbldoZWVsWm9vbSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGRpc2FibGVkID0gX3RoaXMuc2V0dXAuZGlzYWJsZWQ7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IGlzV2hlZWxBbGxvd2VkKF90aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIWlzQWxsb3dlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIga2V5c1ByZXNzZWQgPSBfdGhpcy5pc1ByZXNzaW5nS2V5cyhfdGhpcy5zZXR1cC53aGVlbC5hY3RpdmF0aW9uS2V5cyk7XG4gICAgICAgICAgICBpZiAoIWtleXNQcmVzc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGhhbmRsZVdoZWVsU3RhcnQoX3RoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGhhbmRsZVdoZWVsWm9vbShfdGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgaGFuZGxlV2hlZWxTdG9wKF90aGlzLCBldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vLyAvLy8vLy8vXG4gICAgICAgIC8vIFBhblxuICAgICAgICAvLy8gLy8vLy8vL1xuICAgICAgICB0aGlzLm9uUGFubmluZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBfdGhpcy5zZXR1cC5kaXNhYmxlZDtcbiAgICAgICAgICAgIHZhciBvblBhbm5pbmdTdGFydCA9IF90aGlzLnByb3BzLm9uUGFubmluZ1N0YXJ0O1xuICAgICAgICAgICAgaWYgKGRpc2FibGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSBpc1Bhbm5pbmdTdGFydEFsbG93ZWQoX3RoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBrZXlzUHJlc3NlZCA9IF90aGlzLmlzUHJlc3NpbmdLZXlzKF90aGlzLnNldHVwLnBhbm5pbmcuYWN0aXZhdGlvbktleXMpO1xuICAgICAgICAgICAgaWYgKCFrZXlzUHJlc3NlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxBbmltYXRpb24oX3RoaXMpO1xuICAgICAgICAgICAgaGFuZGxlUGFubmluZ1N0YXJ0KF90aGlzLCBldmVudCk7XG4gICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KF90aGlzKSwgZXZlbnQsIG9uUGFubmluZ1N0YXJ0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblBhbm5pbmcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBkaXNhYmxlZCA9IF90aGlzLnNldHVwLmRpc2FibGVkO1xuICAgICAgICAgICAgdmFyIG9uUGFubmluZyA9IF90aGlzLnByb3BzLm9uUGFubmluZztcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaXNBbGxvd2VkID0gaXNQYW5uaW5nQWxsb3dlZChfdGhpcyk7XG4gICAgICAgICAgICBpZiAoIWlzQWxsb3dlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIga2V5c1ByZXNzZWQgPSBfdGhpcy5pc1ByZXNzaW5nS2V5cyhfdGhpcy5zZXR1cC5wYW5uaW5nLmFjdGl2YXRpb25LZXlzKTtcbiAgICAgICAgICAgIGlmICgha2V5c1ByZXNzZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgaGFuZGxlUGFubmluZyhfdGhpcywgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSk7XG4gICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KF90aGlzKSwgZXZlbnQsIG9uUGFubmluZyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25QYW5uaW5nU3RvcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIG9uUGFubmluZ1N0b3AgPSBfdGhpcy5wcm9wcy5vblBhbm5pbmdTdG9wO1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzUGFubmluZykge1xuICAgICAgICAgICAgICAgIGhhbmRsZVBhbm5pbmdFbmQoX3RoaXMpO1xuICAgICAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoX3RoaXMpLCBldmVudCwgb25QYW5uaW5nU3RvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vLyAvLy8vLy8vXG4gICAgICAgIC8vIFBpbmNoXG4gICAgICAgIC8vLyAvLy8vLy8vXG4gICAgICAgIHRoaXMub25QaW5jaFN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBfdGhpcy5zZXR1cC5kaXNhYmxlZDtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBvblBpbmNoaW5nU3RhcnQgPSBfYS5vblBpbmNoaW5nU3RhcnQsIG9uWm9vbVN0YXJ0ID0gX2Eub25ab29tU3RhcnQ7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IGlzUGluY2hTdGFydEFsbG93ZWQoX3RoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGhhbmRsZVBpbmNoU3RhcnQoX3RoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbEFuaW1hdGlvbihfdGhpcyk7XG4gICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KF90aGlzKSwgZXZlbnQsIG9uUGluY2hpbmdTdGFydCk7XG4gICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KF90aGlzKSwgZXZlbnQsIG9uWm9vbVN0YXJ0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblBpbmNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBfdGhpcy5zZXR1cC5kaXNhYmxlZDtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBvblBpbmNoaW5nID0gX2Eub25QaW5jaGluZywgb25ab29tID0gX2Eub25ab29tO1xuICAgICAgICAgICAgaWYgKGRpc2FibGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSBpc1BpbmNoQWxsb3dlZChfdGhpcyk7XG4gICAgICAgICAgICBpZiAoIWlzQWxsb3dlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBoYW5kbGVQaW5jaFpvb20oX3RoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoX3RoaXMpLCBldmVudCwgb25QaW5jaGluZyk7XG4gICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KF90aGlzKSwgZXZlbnQsIG9uWm9vbSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25QaW5jaFN0b3AgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBvblBpbmNoaW5nU3RvcCA9IF9hLm9uUGluY2hpbmdTdG9wLCBvblpvb21TdG9wID0gX2Eub25ab29tU3RvcDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5waW5jaFN0YXJ0U2NhbGUpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVQaW5jaFN0b3AoX3RoaXMpO1xuICAgICAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoX3RoaXMpLCBldmVudCwgb25QaW5jaGluZ1N0b3ApO1xuICAgICAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoX3RoaXMpLCBldmVudCwgb25ab29tU3RvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vLyAvLy8vLy8vXG4gICAgICAgIC8vIFRvdWNoXG4gICAgICAgIC8vLyAvLy8vLy8vXG4gICAgICAgIHRoaXMub25Ub3VjaFBhbm5pbmdTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGRpc2FibGVkID0gX3RoaXMuc2V0dXAuZGlzYWJsZWQ7XG4gICAgICAgICAgICB2YXIgb25QYW5uaW5nU3RhcnQgPSBfdGhpcy5wcm9wcy5vblBhbm5pbmdTdGFydDtcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaXNBbGxvd2VkID0gaXNQYW5uaW5nU3RhcnRBbGxvd2VkKF90aGlzLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoIWlzQWxsb3dlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaXNEb3VibGVUYXAgPSBfdGhpcy5sYXN0VG91Y2ggJiYgK25ldyBEYXRlKCkgLSBfdGhpcy5sYXN0VG91Y2ggPCAyMDA7XG4gICAgICAgICAgICBpZiAoaXNEb3VibGVUYXAgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkRvdWJsZUNsaWNrKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmxhc3RUb3VjaCA9ICtuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGhhbmRsZUNhbmNlbEFuaW1hdGlvbihfdGhpcyk7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoZXMgPSBldmVudC50b3VjaGVzO1xuICAgICAgICAgICAgICAgIHZhciBpc1Bhbm5pbmdBY3Rpb24gPSB0b3VjaGVzLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgICAgICB2YXIgaXNQaW5jaEFjdGlvbiA9IHRvdWNoZXMubGVuZ3RoID09PSAyO1xuICAgICAgICAgICAgICAgIGlmIChpc1Bhbm5pbmdBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQ2FuY2VsQW5pbWF0aW9uKF90aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlUGFubmluZ1N0YXJ0KF90aGlzLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUNhbGxiYWNrKGdldENvbnRleHQoX3RoaXMpLCBldmVudCwgb25QYW5uaW5nU3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNQaW5jaEFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vblBpbmNoU3RhcnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblRvdWNoUGFubmluZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGRpc2FibGVkID0gX3RoaXMuc2V0dXAuZGlzYWJsZWQ7XG4gICAgICAgICAgICB2YXIgb25QYW5uaW5nID0gX3RoaXMucHJvcHMub25QYW5uaW5nO1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzUGFubmluZyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChkaXNhYmxlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSBpc1Bhbm5pbmdBbGxvd2VkKF90aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWxsb3dlZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgICAgICAgICAgICBoYW5kbGVQYW5uaW5nKF90aGlzLCB0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KF90aGlzKSwgZXZlbnQsIG9uUGFubmluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vblBpbmNoKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblRvdWNoUGFubmluZ1N0b3AgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLm9uUGFubmluZ1N0b3AoZXZlbnQpO1xuICAgICAgICAgICAgX3RoaXMub25QaW5jaFN0b3AoZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICAvLy8gLy8vLy8vL1xuICAgICAgICAvLyBEb3VibGUgQ2xpY2tcbiAgICAgICAgLy8vIC8vLy8vLy9cbiAgICAgICAgdGhpcy5vbkRvdWJsZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBfdGhpcy5zZXR1cC5kaXNhYmxlZDtcbiAgICAgICAgICAgIGlmIChkaXNhYmxlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaXNBbGxvd2VkID0gaXNEb3VibGVDbGlja0FsbG93ZWQoX3RoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghaXNBbGxvd2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGhhbmRsZURvdWJsZUNsaWNrKF90aGlzLCBldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vLyAvLy8vLy8vXG4gICAgICAgIC8vIEhlbHBlcnNcbiAgICAgICAgLy8vIC8vLy8vLy9cbiAgICAgICAgdGhpcy5jbGVhclBhbm5pbmcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc1Bhbm5pbmcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vblBhbm5pbmdTdG9wKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zZXRLZXlQcmVzc2VkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLnByZXNzZWRLZXlzW2Uua2V5XSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0S2V5VW5QcmVzc2VkID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzLnByZXNzZWRLZXlzW2Uua2V5XSA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzUHJlc3NpbmdLZXlzID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgICAgIGlmICgha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGtleXMuZmluZChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBfdGhpcy5wcmVzc2VkS2V5c1trZXldOyB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtU3RhdGUgPSBmdW5jdGlvbiAoc2NhbGUsIHBvc2l0aW9uWCwgcG9zaXRpb25ZKSB7XG4gICAgICAgICAgICB2YXIgb25UcmFuc2Zvcm1lZCA9IF90aGlzLnByb3BzLm9uVHJhbnNmb3JtZWQ7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihzY2FsZSkgJiZcbiAgICAgICAgICAgICAgICAhTnVtYmVyLmlzTmFOKHBvc2l0aW9uWCkgJiZcbiAgICAgICAgICAgICAgICAhTnVtYmVyLmlzTmFOKHBvc2l0aW9uWSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NhbGUgIT09IF90aGlzLnRyYW5zZm9ybVN0YXRlLnNjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnRyYW5zZm9ybVN0YXRlLnByZXZpb3VzU2NhbGUgPSBfdGhpcy50cmFuc2Zvcm1TdGF0ZS5zY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJhbnNmb3JtU3RhdGUuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhbnNmb3JtU3RhdGUucG9zaXRpb25YID0gcG9zaXRpb25YO1xuICAgICAgICAgICAgICAgIF90aGlzLnRyYW5zZm9ybVN0YXRlLnBvc2l0aW9uWSA9IHBvc2l0aW9uWTtcbiAgICAgICAgICAgICAgICB2YXIgY3R4XzEgPSBnZXRDb250ZXh0KF90aGlzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkNoYW5nZUNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gY2FsbGJhY2soY3R4XzEpOyB9KTtcbiAgICAgICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhjdHhfMSwgeyBzY2FsZTogc2NhbGUsIHBvc2l0aW9uWDogcG9zaXRpb25YLCBwb3NpdGlvblk6IHBvc2l0aW9uWSB9LCBvblRyYW5zZm9ybWVkKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hcHBseVRyYW5zZm9ybWF0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRGV0ZWN0ZWQgTmFOIHNldCBzdGF0ZSB2YWx1ZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0Q2VudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLndyYXBwZXJDb21wb25lbnQgJiYgX3RoaXMuY29udGVudENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRTdGF0ZSA9IGdldENlbnRlclBvc2l0aW9uKF90aGlzLnRyYW5zZm9ybVN0YXRlLnNjYWxlLCBfdGhpcy53cmFwcGVyQ29tcG9uZW50LCBfdGhpcy5jb250ZW50Q29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRUcmFuc2Zvcm1TdGF0ZSh0YXJnZXRTdGF0ZS5zY2FsZSwgdGFyZ2V0U3RhdGUucG9zaXRpb25YLCB0YXJnZXRTdGF0ZS5wb3NpdGlvblkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRyYW5zZm9ybVN0eWxlcyA9IGZ1bmN0aW9uICh4LCB5LCBzY2FsZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmN1c3RvbVRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5jdXN0b21UcmFuc2Zvcm0oeCwgeSwgc2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldFRyYW5zZm9ybVN0eWxlcyh4LCB5LCBzY2FsZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMubW91bnRlZCB8fCAhX3RoaXMuY29udGVudENvbXBvbmVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy50cmFuc2Zvcm1TdGF0ZSwgc2NhbGUgPSBfYS5zY2FsZSwgcG9zaXRpb25YID0gX2EucG9zaXRpb25YLCBwb3NpdGlvblkgPSBfYS5wb3NpdGlvblk7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gX3RoaXMuaGFuZGxlVHJhbnNmb3JtU3R5bGVzKHBvc2l0aW9uWCwgcG9zaXRpb25ZLCBzY2FsZSk7XG4gICAgICAgICAgICBfdGhpcy5jb250ZW50Q29tcG9uZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbnRleHQoX3RoaXMpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLm9uQ2hhbmdlQ2FsbGJhY2tzLmhhcyhjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkNoYW5nZUNhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkNoYW5nZUNhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXQgPSBmdW5jdGlvbiAod3JhcHBlckNvbXBvbmVudCwgY29udGVudENvbXBvbmVudCkge1xuICAgICAgICAgICAgX3RoaXMuY2xlYW51cFdpbmRvd0V2ZW50cygpO1xuICAgICAgICAgICAgX3RoaXMud3JhcHBlckNvbXBvbmVudCA9IHdyYXBwZXJDb21wb25lbnQ7XG4gICAgICAgICAgICBfdGhpcy5jb250ZW50Q29tcG9uZW50ID0gY29udGVudENvbXBvbmVudDtcbiAgICAgICAgICAgIGhhbmRsZUNhbGN1bGF0ZUJvdW5kcyhfdGhpcywgX3RoaXMudHJhbnNmb3JtU3RhdGUuc2NhbGUpO1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlSW5pdGlhbGl6ZVdyYXBwZXJFdmVudHMod3JhcHBlckNvbXBvbmVudCk7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVJbml0aWFsaXplKGNvbnRlbnRDb21wb25lbnQpO1xuICAgICAgICAgICAgX3RoaXMuaW5pdGlhbGl6ZVdpbmRvd0V2ZW50cygpO1xuICAgICAgICAgICAgX3RoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICBoYW5kbGVDYWxsYmFjayhnZXRDb250ZXh0KF90aGlzKSwgdW5kZWZpbmVkLCBfdGhpcy5wcm9wcy5vbkluaXQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuc2V0dXAgPSBjcmVhdGVTZXR1cCh0aGlzLnByb3BzKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1TdGF0ZSA9IGNyZWF0ZVN0YXRlKHRoaXMucHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gWm9vbVBhblBpbmNoO1xufSgpKTtcblxudmFyIENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xudmFyIGdldENvbnRlbnQgPSBmdW5jdGlvbiAoY2hpbGRyZW4sIGN0eCkge1xuICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW4oY3R4KTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xufTtcbnZhciBUcmFuc2Zvcm1XcmFwcGVyID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICAgIHZhciBfYSA9IHVzZVN0YXRlKDApLCBmb3JjZVVwZGF0ZSA9IF9hWzFdO1xuICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBpbnN0YW5jZSA9IHVzZVJlZihuZXcgWm9vbVBhblBpbmNoKHByb3BzKSkuY3VycmVudDtcbiAgICB2YXIgY29udGVudCA9IGdldENvbnRlbnQocHJvcHMuY2hpbGRyZW4sIGdldENvbnRleHQoaW5zdGFuY2UpKTtcbiAgICB2YXIgaGFuZGxlT25DaGFuZ2UgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZm9yY2VVcGRhdGUoZnVuY3Rpb24gKHByZXYpIHsgcmV0dXJuIHByZXYgKyAxOyB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtjaGlsZHJlbl0pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRDb250ZXh0KGluc3RhbmNlKTsgfSwgW2luc3RhbmNlXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5zdGFuY2UudXBkYXRlKHByb3BzKTtcbiAgICB9LCBbaW5zdGFuY2UsIHByb3BzXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLm9uQ2hhbmdlKGhhbmRsZU9uQ2hhbmdlKTtcbiAgICB9LCBbaW5zdGFuY2UsIHByb3BzLCBoYW5kbGVPbkNoYW5nZV0pO1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGluc3RhbmNlIH0sIGNvbnRlbnQpO1xufSk7XG5cbmZ1bmN0aW9uIHN0eWxlSW5qZWN0KGNzcywgcmVmKSB7XG4gIGlmICggcmVmID09PSB2b2lkIDAgKSByZWYgPSB7fTtcbiAgdmFyIGluc2VydEF0ID0gcmVmLmluc2VydEF0O1xuXG4gIGlmICghY3NzIHx8IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuOyB9XG5cbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xuXG4gIGlmIChpbnNlcnRBdCA9PT0gJ3RvcCcpIHtcbiAgICBpZiAoaGVhZC5maXJzdENoaWxkKSB7XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShzdHlsZSwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9XG5cbiAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxudmFyIGNzc18yNDh6ID0gXCIudHJhbnNmb3JtLWNvbXBvbmVudC1tb2R1bGVfd3JhcHBlcl9fN0hGSmUge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgd2lkdGg6IC1tb3otZml0LWNvbnRlbnQ7XFxuICB3aWR0aDogZml0LWNvbnRlbnQ7XFxuICBoZWlnaHQ6IC1tb3otZml0LWNvbnRlbnQ7XFxuICBoZWlnaHQ6IGZpdC1jb250ZW50O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTsgLyogaU9TIFNhZmFyaSAqL1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTsgLyogU2FmYXJpICovXFxuICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEtvbnF1ZXJvciBIVE1MICovXFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lOyAvKiBGaXJlZm94ICovXFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7IC8qIEludGVybmV0IEV4cGxvcmVyL0VkZ2UgKi9cXG4gIHVzZXItc2VsZWN0OiBub25lO1xcbiAgbWFyZ2luOiAwO1xcbiAgcGFkZGluZzogMDtcXG59XFxuLnRyYW5zZm9ybS1jb21wb25lbnQtbW9kdWxlX2NvbnRlbnRfX3VDRFBFIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LXdyYXA6IHdyYXA7XFxuICB3aWR0aDogLW1vei1maXQtY29udGVudDtcXG4gIHdpZHRoOiBmaXQtY29udGVudDtcXG4gIGhlaWdodDogLW1vei1maXQtY29udGVudDtcXG4gIGhlaWdodDogZml0LWNvbnRlbnQ7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbiAgdHJhbnNmb3JtLW9yaWdpbjogMCUgMCU7XFxufVxcbi50cmFuc2Zvcm0tY29tcG9uZW50LW1vZHVsZV9jb250ZW50X191Q0RQRSBpbWcge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblwiO1xudmFyIHN0eWxlcyA9IHtcIndyYXBwZXJcIjpcInRyYW5zZm9ybS1jb21wb25lbnQtbW9kdWxlX3dyYXBwZXJfXzdIRkplXCIsXCJjb250ZW50XCI6XCJ0cmFuc2Zvcm0tY29tcG9uZW50LW1vZHVsZV9jb250ZW50X191Q0RQRVwifTtcbnN0eWxlSW5qZWN0KGNzc18yNDh6KTtcblxudmFyIFRyYW5zZm9ybUNvbXBvbmVudCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBfYiA9IF9hLndyYXBwZXJDbGFzcywgd3JhcHBlckNsYXNzID0gX2IgPT09IHZvaWQgMCA/IFwiXCIgOiBfYiwgX2MgPSBfYS5jb250ZW50Q2xhc3MsIGNvbnRlbnRDbGFzcyA9IF9jID09PSB2b2lkIDAgPyBcIlwiIDogX2MsIHdyYXBwZXJTdHlsZSA9IF9hLndyYXBwZXJTdHlsZSwgY29udGVudFN0eWxlID0gX2EuY29udGVudFN0eWxlLCBfZCA9IF9hLndyYXBwZXJQcm9wcywgd3JhcHBlclByb3BzID0gX2QgPT09IHZvaWQgMCA/IHt9IDogX2QsIF9lID0gX2EuY29udGVudFByb3BzLCBjb250ZW50UHJvcHMgPSBfZSA9PT0gdm9pZCAwID8ge30gOiBfZTtcbiAgICB2YXIgaW5pdCA9IHVzZUNvbnRleHQoQ29udGV4dCkuaW5pdDtcbiAgICB2YXIgd3JhcHBlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgICB2YXIgY29udGVudFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHdyYXBwZXJSZWYuY3VycmVudDtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSBjb250ZW50UmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICh3cmFwcGVyICE9PSBudWxsICYmIGNvbnRlbnQgIT09IG51bGwgJiYgaW5pdCkge1xuICAgICAgICAgICAgaW5pdCh3cmFwcGVyLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW10pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfX2Fzc2lnbih7fSwgd3JhcHBlclByb3BzLCB7IHJlZjogd3JhcHBlclJlZiwgY2xhc3NOYW1lOiBcInJlYWN0LXRyYW5zZm9ybS13cmFwcGVyIFwiLmNvbmNhdChzdHlsZXMud3JhcHBlciwgXCIgXCIpLmNvbmNhdCh3cmFwcGVyQ2xhc3MpLCBzdHlsZTogd3JhcHBlclN0eWxlIH0pLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9fYXNzaWduKHt9LCBjb250ZW50UHJvcHMsIHsgcmVmOiBjb250ZW50UmVmLCBjbGFzc05hbWU6IFwicmVhY3QtdHJhbnNmb3JtLWNvbXBvbmVudCBcIi5jb25jYXQoc3R5bGVzLmNvbnRlbnQsIFwiIFwiKS5jb25jYXQoY29udGVudENsYXNzKSwgc3R5bGU6IGNvbnRlbnRTdHlsZSB9KSwgY2hpbGRyZW4pKSk7XG59O1xuXG52YXIgdXNlVHJhbnNmb3JtQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbGlicmFyeUNvbnRleHQgPSB1c2VDb250ZXh0KENvbnRleHQpO1xuICAgIHZhciBfYSA9IHVzZVN0YXRlKGdldENvbnRleHQobGlicmFyeUNvbnRleHQgfHwge30pKSwgdmFsdWVzID0gX2FbMF0sIHNldFZhbHVlcyA9IF9hWzFdO1xuICAgIGlmICghbGlicmFyeUNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNmb3JtIGNvbnRleHQgbXVzIGJlIHBsYWNlZCBpbnNpZGUgVHJhbnNmb3JtV3JhcHBlclwiKTtcbiAgICB9XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGlicmFyeUNvbnRleHQub25DaGFuZ2UoZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgICAgc2V0VmFsdWVzKHJlZik7XG4gICAgICAgIH0pO1xuICAgIH0sIFtsaWJyYXJ5Q29udGV4dF0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG59O1xuXG52YXIgS2VlcFNjYWxlID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICAgIHZhciBsb2NhbFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICB2YXIgaW5zdGFuY2UgPSB1c2VDb250ZXh0KENvbnRleHQpO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5vbkNoYW5nZShmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICBpZiAobG9jYWxSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvblggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvblkgPSAwO1xuICAgICAgICAgICAgICAgIGxvY2FsUmVmLmN1cnJlbnQuc3R5bGUudHJhbnNmb3JtID0gaW5zdGFuY2UuaGFuZGxlVHJhbnNmb3JtU3R5bGVzKHBvc2l0aW9uWCwgcG9zaXRpb25ZLCAxIC8gY3R4LnN0YXRlLnNjYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSwgW2luc3RhbmNlXSk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX19hc3NpZ24oe30sIHByb3BzLCB7IHJlZjogbWVyZ2VSZWZzKFtsb2NhbFJlZiwgcmVmXSkgfSkpO1xufSk7XG5cbmV4cG9ydCB7IEtlZXBTY2FsZSwgVHJhbnNmb3JtQ29tcG9uZW50LCBUcmFuc2Zvcm1XcmFwcGVyLCBnZXRDZW50ZXJQb3NpdGlvbiwgZ2V0TWF0cml4VHJhbnNmb3JtU3R5bGVzLCBnZXRUcmFuc2Zvcm1TdHlsZXMsIHVzZVRyYW5zZm9ybUNvbnRleHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVN0YXRlIiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlRWZmZWN0IiwidXNlQ29udGV4dCIsInJvdW5kTnVtYmVyIiwibnVtIiwiZGVjaW1hbCIsIk51bWJlciIsInRvRml4ZWQiLCJjaGVja0lzTnVtYmVyIiwiZGVmYXVsdFZhbHVlIiwiaGFuZGxlQ2FsbGJhY2siLCJjb250ZXh0IiwiZXZlbnQiLCJjYWxsYmFjayIsImVhc2VPdXQiLCJ0IiwiTWF0aCIsImNvcyIsIlBJIiwibGluZWFyIiwiZWFzZUluUXVhZCIsImVhc2VPdXRRdWFkIiwiZWFzZUluT3V0UXVhZCIsImVhc2VJbkN1YmljIiwiZWFzZU91dEN1YmljIiwiZWFzZUluT3V0Q3ViaWMiLCJlYXNlSW5RdWFydCIsImVhc2VPdXRRdWFydCIsImVhc2VJbk91dFF1YXJ0IiwiZWFzZUluUXVpbnQiLCJlYXNlT3V0UXVpbnQiLCJlYXNlSW5PdXRRdWludCIsImFuaW1hdGlvbnMiLCJoYW5kbGVDYW5jZWxBbmltYXRpb25GcmFtZSIsImFuaW1hdGlvbiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaGFuZGxlQ2FuY2VsQW5pbWF0aW9uIiwiY29udGV4dEluc3RhbmNlIiwibW91bnRlZCIsImFuaW1hdGUiLCJ2ZWxvY2l0eSIsImhhbmRsZVNldHVwQW5pbWF0aW9uIiwiYW5pbWF0aW9uTmFtZSIsImFuaW1hdGlvblRpbWUiLCJzdGFydFRpbWUiLCJEYXRlIiwiZ2V0VGltZSIsImxhc3RTdGVwIiwiZnJhbWVUaW1lIiwiYW5pbWF0aW9uUHJvZ3Jlc3MiLCJhbmltYXRpb25UeXBlIiwic3RlcCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImlzVmFsaWRUYXJnZXRTdGF0ZSIsInRhcmdldFN0YXRlIiwic2NhbGUiLCJwb3NpdGlvblgiLCJwb3NpdGlvblkiLCJpc05hTiIsImlzVmFsaWQiLCJzZXRUcmFuc2Zvcm1TdGF0ZSIsIl9hIiwidHJhbnNmb3JtU3RhdGUiLCJzY2FsZURpZmYiLCJwb3NpdGlvblhEaWZmIiwicG9zaXRpb25ZRGlmZiIsIm5ld1NjYWxlIiwibmV3UG9zaXRpb25YIiwibmV3UG9zaXRpb25ZIiwiZ2V0Q29tcG9uZW50c1NpemVzIiwid3JhcHBlckNvbXBvbmVudCIsImNvbnRlbnRDb21wb25lbnQiLCJ3cmFwcGVyV2lkdGgiLCJvZmZzZXRXaWR0aCIsIndyYXBwZXJIZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJjb250ZW50V2lkdGgiLCJjb250ZW50SGVpZ2h0IiwibmV3Q29udGVudFdpZHRoIiwibmV3Q29udGVudEhlaWdodCIsIm5ld0RpZmZXaWR0aCIsIm5ld0RpZmZIZWlnaHQiLCJnZXRCb3VuZHMiLCJkaWZmV2lkdGgiLCJkaWZmSGVpZ2h0IiwiY2VudGVyWm9vbWVkT3V0Iiwic2NhbGVXaWR0aEZhY3RvciIsInNjYWxlSGVpZ2h0RmFjdG9yIiwibWluUG9zaXRpb25YIiwibWF4UG9zaXRpb25YIiwibWluUG9zaXRpb25ZIiwibWF4UG9zaXRpb25ZIiwiY2FsY3VsYXRlQm91bmRzIiwic2V0dXAiLCJFcnJvciIsImJvdW5kcyIsIkJvb2xlYW4iLCJib3VuZExpbWl0ZXIiLCJ2YWx1ZSIsIm1pbkJvdW5kIiwibWF4Qm91bmQiLCJpc0FjdGl2ZSIsImhhbmRsZUNhbGN1bGF0ZUJvdW5kcyIsImdldE1vdXNlQm91bmRlZFBvc2l0aW9uIiwibGltaXRUb0JvdW5kcyIsInBhZGRpbmdWYWx1ZVgiLCJwYWRkaW5nVmFsdWVZIiwicGFkZGluZ1giLCJwYWRkaW5nWSIsIngiLCJ5IiwiaGFuZGxlQ2FsY3VsYXRlWm9vbVBvc2l0aW9ucyIsIm1vdXNlWCIsIm1vdXNlWSIsInNjYWxlRGlmZmVyZW5jZSIsImNvbnNvbGUiLCJlcnJvciIsImNhbGN1bGF0ZWRQb3NpdGlvblgiLCJjYWxjdWxhdGVkUG9zaXRpb25ZIiwibmV3UG9zaXRpb25zIiwiY2hlY2tab29tQm91bmRzIiwiem9vbSIsIm1pblNjYWxlIiwibWF4U2NhbGUiLCJ6b29tUGFkZGluZyIsImVuYWJsZVBhZGRpbmciLCJzY2FsZVBhZGRpbmciLCJtaW5TY2FsZVdpdGhQYWRkaW5nIiwiaXNQYW5uaW5nU3RhcnRBbGxvd2VkIiwiZXhjbHVkZWQiLCJwYW5uaW5nIiwiaXNJbml0aWFsaXplZCIsInRhcmdldCIsImlzV3JhcHBlckNoaWxkIiwiY29udGFpbnMiLCJpc0FsbG93ZWQiLCJpc0V4Y2x1ZGVkIiwiaXNFeGNsdWRlZE5vZGUiLCJpc1Bhbm5pbmdBbGxvd2VkIiwiaXNQYW5uaW5nIiwiZGlzYWJsZWQiLCJoYW5kbGVQYW5uaW5nU2V0dXAiLCJjbGllbnRYIiwiY2xpZW50WSIsInN0YXJ0Q29vcmRzIiwiaGFuZGxlVG91Y2hQYW5uaW5nU2V0dXAiLCJ0b3VjaGVzIiwib25lRmluZ2VyVG91Y2giLCJsZW5ndGgiLCJoYW5kbGVQYW5Ub0JvdW5kcyIsIl9iIiwiX2MiLCJ4Q2hhbmdlZCIsInlDaGFuZ2VkIiwibW91c2VQb3NYIiwibW91c2VQb3NZIiwiX2QiLCJoYW5kbGVOZXdQb3NpdGlvbiIsImdldFBhbm5pbmdDbGllbnRQb3NpdGlvbiIsImxvY2tBeGlzWCIsImxvY2tBeGlzWSIsImdldFBhZGRpbmdWYWx1ZSIsInNpemUiLCJkaXNhYmxlUGFkZGluZyIsImlzVmVsb2NpdHlDYWxjdWxhdGlvbkFsbG93ZWQiLCJ2ZWxvY2l0eUFuaW1hdGlvbiIsImRpc2FibGVkVmVsb2NpdHkiLCJpc1ZlbG9jaXR5QWxsb3dlZCIsImdldFZlbG9jaXR5TW92ZVRpbWUiLCJlcXVhbFRvTW92ZSIsInNlbnNpdGl2aXR5IiwiZ2V0VmVsb2NpdHlQb3NpdGlvbiIsIm5ld1Bvc2l0aW9uIiwic3RhcnRQb3NpdGlvbiIsImN1cnJlbnRQb3NpdGlvbiIsImlzTG9ja2VkIiwibWluUG9zaXRpb24iLCJtYXhQb3NpdGlvbiIsIm1pblRhcmdldCIsIm1heFRhcmdldCIsImNhbGN1bGF0ZWRQb3NpdGlvbiIsImdldFNpemVNdWx0aXBsaWVyIiwiZGVmYXVsdE11bHRpcGxpZXIiLCJtaW4iLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiaGFuZGxlQ2FsY3VsYXRlVmVsb2NpdHkiLCJwb3NpdGlvbiIsImxhc3RNb3VzZVBvc2l0aW9uIiwidmVsb2NpdHlUaW1lIiwibm93Iiwic2l6ZU11bHRpcGxpZXIiLCJkaXN0YW5jZVgiLCJkaXN0YW5jZVkiLCJ2ZWxvY2l0eVgiLCJ2ZWxvY2l0eVkiLCJpbnRlcnZhbCIsInNwZWVkIiwic3FydCIsInRvdGFsIiwiaGFuZGxlVmVsb2NpdHlQYW5uaW5nIiwiYWxpZ25tZW50QW5pbWF0aW9uIiwiem9vbUFuaW1hdGlvbiIsInNpemVYIiwic2l6ZVkiLCJ2ZWxvY2l0eUFsaWdubWVudFRpbWUiLCJhbGlnbkFuaW1hdGlvblRpbWUiLCJtb3ZlQW5pbWF0aW9uVGltZSIsImZpbmFsQW5pbWF0aW9uVGltZSIsIm1heCIsIm1heFRhcmdldFgiLCJtaW5UYXJnZXRYIiwibWF4VGFyZ2V0WSIsIm1pblRhcmdldFkiLCJzdGFydFN0YXRlIiwiYWxpZ25BbmltYXRpb24iLCJhbGlnblN0ZXAiLCJjdXN0b21TdGVwIiwiY3VycmVudFBvc2l0aW9uWCIsImN1cnJlbnRQb3NpdGlvblkiLCJoYW5kbGVQYW5uaW5nU3RhcnQiLCJUb3VjaEV2ZW50IiwidW5kZWZpbmVkIiwiaGFuZGxlQWxpZ25Ub0JvdW5kcyIsImlzRGlzYWJsZWQiLCJoYW5kbGVQYW5uaW5nIiwiaGFuZGxlUGFubmluZ0VuZCIsInZlbG9jaXR5RGlzYWJsZWQiLCJ3cmFwcGVyUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNvbnRlbnRSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJpc1pvb21lZCIsInNob3VsZEFuaW1hdGUiLCJoYW5kbGVab29tVG9Qb2ludCIsImhhbmRsZUFsaWduVG9TY2FsZUJvdW5kcyIsIm1vdXNlUG9zaXRpb25YIiwibW91c2VQb3NpdGlvblkiLCJfX2Fzc2lnbiIsIk9iamVjdCIsImFzc2lnbiIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9fc3ByZWFkQXJyYXkiLCJ0byIsImZyb20iLCJwYWNrIiwibCIsImFyIiwiQXJyYXkiLCJzbGljZSIsImNvbmNhdCIsImluaXRpYWxTdGF0ZSIsInByZXZpb3VzU2NhbGUiLCJpbml0aWFsU2V0dXAiLCJjZW50ZXJPbkluaXQiLCJ3aGVlbCIsIndoZWVsRGlzYWJsZWQiLCJ0b3VjaFBhZERpc2FibGVkIiwiYWN0aXZhdGlvbktleXMiLCJwaW5jaCIsImRvdWJsZUNsaWNrIiwibW9kZSIsImNyZWF0ZVN0YXRlIiwicHJvcHMiLCJpbml0aWFsU2NhbGUiLCJpbml0aWFsUG9zaXRpb25YIiwiaW5pdGlhbFBvc2l0aW9uWSIsImNyZWF0ZVNldHVwIiwibmV3U2V0dXAiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsInZhbGlkVmFsdWUiLCJ2YWxpZFBhcmFtZXRlciIsImRhdGFUeXBlIiwidG9TdHJpbmciLCJpc09iamVjdCIsImlzQXJyYXkiLCJoYW5kbGVDYWxjdWxhdGVCdXR0b25ab29tIiwiZGVsdGEiLCJ0YXJnZXRTY2FsZSIsImV4cCIsImhhbmRsZVpvb21Ub1ZpZXdDZW50ZXIiLCJyZXNldFRyYW5zZm9ybWF0aW9ucyIsIm9uUmVzZXRUcmFuc2Zvcm1hdGlvbiIsImluaXRpYWxUcmFuc2Zvcm1hdGlvbiIsIm5ld0JvdW5kcyIsImJvdW5kZWRQb3NpdGlvbnMiLCJuZXdTdGF0ZSIsImdldE9mZnNldCIsImVsZW1lbnQiLCJ3cmFwcGVyIiwiY29udGVudCIsInN0YXRlIiwib2Zmc2V0Iiwid3JhcHBlck9mZnNldCIsImNvbnRlbnRPZmZzZXQiLCJ4T2ZmIiwieU9mZiIsImNhbGN1bGF0ZVpvb21Ub05vZGUiLCJub2RlIiwiY3VzdG9tWm9vbSIsIm5vZGVSZWN0Iiwibm9kZU9mZnNldCIsIm5vZGVMZWZ0Iiwibm9kZVRvcCIsIm5vZGVXaWR0aCIsIm5vZGVIZWlnaHQiLCJzY2FsZVgiLCJzY2FsZVkiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImxlZnQiLCJ0b3AiLCJ6b29tSW4iLCJ6b29tT3V0Iiwic2V0VHJhbnNmb3JtIiwicmVzZXRUcmFuc2Zvcm0iLCJjZW50ZXJWaWV3IiwiZ2V0Q2VudGVyUG9zaXRpb24iLCJ6b29tVG9FbGVtZW50IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsImdldENvbnRleHQiLCJpbnN0YW5jZSIsInBhc3NpdmVTdXBwb3J0ZWQiLCJtYWtlUGFzc2l2ZUV2ZW50T3B0aW9uIiwib3B0aW9ucyIsInBhc3NpdmUiLCJlcnIiLCJ0YXJnZXRUYWdOYW1lIiwidGFnTmFtZSIsInRvVXBwZXJDYXNlIiwiaXNFeGNsdWRlZFRhZyIsImZpbmQiLCJ0YWciLCJpc0V4Y2x1ZGVkQ2xhc3NOYW1lIiwiY2xhc3NOYW1lIiwiY2xhc3NMaXN0IiwiY2FuY2VsVGltZW91dCIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJnZXRUcmFuc2Zvcm1TdHlsZXMiLCJnZXRNYXRyaXhUcmFuc2Zvcm1TdHlsZXMiLCJhIiwiYiIsImMiLCJkIiwidHgiLCJ0eSIsImNlbnRlclBvc2l0aW9uWCIsImNlbnRlclBvc2l0aW9uWSIsIm1lcmdlUmVmcyIsInJlZnMiLCJyZWYiLCJjdXJyZW50IiwiaXNXaGVlbEFsbG93ZWQiLCJjdHJsS2V5IiwiZ2V0RGVsdGFZIiwiZGVsdGFZIiwiZ2V0RGVsdGEiLCJjdXN0b21EZWx0YSIsImdldE1vdXNlUG9zaXRpb24iLCJ0b3VjaCIsImhhbmRsZUNhbGN1bGF0ZVdoZWVsWm9vbSIsImRpc2FibGUiLCJnZXRUYXJnZXQiLCJwYWRkaW5nRW5hYmxlZCIsImhhbmRsZVdoZWVsWm9vbVN0b3AiLCJwcmV2aW91c1doZWVsRXZlbnQiLCJzaWduIiwiaXNQaW5jaFN0YXJ0QWxsb3dlZCIsImlzUGluY2hBbGxvd2VkIiwicGluY2hTdGFydERpc3RhbmNlIiwiY2FsY3VsYXRlVG91Y2hNaWRQb2ludCIsImZpcnN0UG9pbnRYIiwiZmlyc3RQb2ludFkiLCJzZWNvbmRQb2ludFgiLCJzZWNvbmRQb2ludFkiLCJnZXRUb3VjaERpc3RhbmNlIiwicG93IiwicGFnZVgiLCJwYWdlWSIsImNhbGN1bGF0ZVBpbmNoWm9vbSIsImN1cnJlbnREaXN0YW5jZSIsInBpbmNoU3RhcnRTY2FsZSIsInRvdWNoUHJvcG9ydGlvbiIsIndoZWVsU3RvcEV2ZW50VGltZSIsIndoZWVsQW5pbWF0aW9uVGltZSIsImhhbmRsZVdoZWVsU3RhcnQiLCJvbldoZWVsU3RhcnQiLCJvblpvb21TdGFydCIsIndoZWVsU3RvcEV2ZW50VGltZXIiLCJoYW5kbGVXaGVlbFpvb20iLCJvbldoZWVsIiwib25ab29tIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJtb3VzZVBvc2l0aW9uIiwiaXNQYWRkaW5nRGlzYWJsZWQiLCJpc0xpbWl0ZWRUb0JvdW5kcyIsImhhbmRsZVdoZWVsU3RvcCIsIm9uV2hlZWxTdG9wIiwib25ab29tU3RvcCIsIndoZWVsQW5pbWF0aW9uVGltZXIiLCJzZXRUaW1lb3V0IiwiaGFzU3RvcHBlZFpvb21pbmciLCJoYW5kbGVQaW5jaFN0YXJ0IiwiZGlzdGFuY2UiLCJsYXN0RGlzdGFuY2UiLCJoYW5kbGVQaW5jaFpvb20iLCJtaWRQb2ludCIsImlzRmluaXRlIiwicGluY2hNaWRwb2ludCIsImhhbmRsZVBpbmNoU3RvcCIsImhhbmRsZURvdWJsZUNsaWNrU3RvcCIsImRvdWJsZUNsaWNrU3RvcEV2ZW50VGltZXIiLCJoYW5kbGVEb3VibGVDbGlja1Jlc2V0TW9kZSIsImhhbmRsZURvdWJsZUNsaWNrIiwiaXNEb3VibGVDbGlja0FsbG93ZWQiLCJab29tUGFuUGluY2giLCJfdGhpcyIsIm9uQ2hhbmdlQ2FsbGJhY2tzIiwiU2V0IiwibGFzdFRvdWNoIiwibWF4Qm91bmRzIiwicHJlc3NlZEtleXMiLCJtb3VudCIsImluaXRpYWxpemVXaW5kb3dFdmVudHMiLCJ1bm1vdW50IiwiY2xlYW51cFdpbmRvd0V2ZW50cyIsInVwZGF0ZSIsIm5ld1Byb3BzIiwiY3VycmVudERvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsImN1cnJlbnRXaW5kb3ciLCJkZWZhdWx0VmlldyIsImFkZEV2ZW50TGlzdGVuZXIiLCJvblBhbm5pbmdTdGFydCIsIm9uUGFubmluZyIsIm9uUGFubmluZ1N0b3AiLCJjbGVhclBhbm5pbmciLCJzZXRLZXlVblByZXNzZWQiLCJzZXRLZXlQcmVzc2VkIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9ic2VydmVyIiwiZGlzY29ubmVjdCIsImhhbmRsZUluaXRpYWxpemVXcmFwcGVyRXZlbnRzIiwib25XaGVlbFpvb20iLCJvbkRvdWJsZUNsaWNrIiwib25Ub3VjaFBhbm5pbmdTdGFydCIsIm9uVG91Y2hQYW5uaW5nIiwib25Ub3VjaFBhbm5pbmdTdG9wIiwiaGFuZGxlSW5pdGlhbGl6ZSIsImFwcGx5VHJhbnNmb3JtYXRpb24iLCJzZXRDZW50ZXIiLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJrZXlzUHJlc3NlZCIsImlzUHJlc3NpbmdLZXlzIiwib25QaW5jaFN0YXJ0Iiwib25QaW5jaGluZ1N0YXJ0Iiwib25QaW5jaCIsIm9uUGluY2hpbmciLCJvblBpbmNoU3RvcCIsIm9uUGluY2hpbmdTdG9wIiwiaXNEb3VibGVUYXAiLCJpc1Bhbm5pbmdBY3Rpb24iLCJpc1BpbmNoQWN0aW9uIiwiZSIsIm9uVHJhbnNmb3JtZWQiLCJjdHhfMSIsImhhbmRsZVRyYW5zZm9ybVN0eWxlcyIsImN1c3RvbVRyYW5zZm9ybSIsInRyYW5zZm9ybSIsInN0eWxlIiwib25DaGFuZ2UiLCJoYXMiLCJhZGQiLCJkZWxldGUiLCJpbml0Iiwib25Jbml0IiwiQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJnZXRDb250ZW50IiwiY2hpbGRyZW4iLCJjdHgiLCJUcmFuc2Zvcm1XcmFwcGVyIiwiZm9yd2FyZFJlZiIsImZvcmNlVXBkYXRlIiwiaGFuZGxlT25DaGFuZ2UiLCJwcmV2IiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwic3R5bGVJbmplY3QiLCJjc3MiLCJpbnNlcnRBdCIsImhlYWQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInR5cGUiLCJmaXJzdENoaWxkIiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJzdHlsZVNoZWV0IiwiY3NzVGV4dCIsImNyZWF0ZVRleHROb2RlIiwiY3NzXzI0OHoiLCJzdHlsZXMiLCJUcmFuc2Zvcm1Db21wb25lbnQiLCJ3cmFwcGVyQ2xhc3MiLCJjb250ZW50Q2xhc3MiLCJ3cmFwcGVyU3R5bGUiLCJjb250ZW50U3R5bGUiLCJ3cmFwcGVyUHJvcHMiLCJfZSIsImNvbnRlbnRQcm9wcyIsIndyYXBwZXJSZWYiLCJjb250ZW50UmVmIiwidXNlVHJhbnNmb3JtQ29udGV4dCIsImxpYnJhcnlDb250ZXh0IiwidmFsdWVzIiwic2V0VmFsdWVzIiwiS2VlcFNjYWxlIiwibG9jYWxSZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-zoom-pan-pinch/dist/index.esm.js\n");

/***/ })

};
;